<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Pallet - agile provisioning and configuration of compute nodes. A devops tool." name="description" /><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">/*!
 * Copyright  2010 Sattvik Software & Technology Resources, Ltd. Co.
 * All rights reserved.
 *
 * sh-clojure may be used under the terms of either the GNU Lesser General Public
 * License (LGPL) or the Eclipse Public License (EPL).  As a recipient of
 * sh-clojure, you may choose which license to receive the code under.  See the
 * LICENSE file distributed with sh-clojure for details.
 *
 * Written by Daniel Solano Gmez
 *
 * Version 0.9.1 - 10 Apr 2010
 */

function ClojureRegExp(pattern) {
	pattern = pattern + '(?=[[\\]{}(),\\s])';
	this.regex = new RegExp(pattern, 'g');
	this.lookBehind = /[\[\]{}(),\s]$/;
}

ClojureRegExp.prototype.exec = function (str) {
	var match, leftContext;
	while (match=this.regex.exec(str)) {
		leftContext = str.substring(0, match.index);
		if (this.lookBehind.test(leftContext)) {
			return match;
		}
		else {
			this.regex.lastIndex = match.index + 1;
		}
	}
	return null;
};

SyntaxHighlighter.brushes.Clojure = function () {
	var special_forms =
			'. def do fn if let loop monitor-enter monitor-exit new quote recur set! ' +
			'throw try var',
	    clojure_core =
			'* *1 *2 *3 *agent* *allow-unresolved-vars* *assert* *clojure-version* ' +
			'*command-line-args* *compile-files* *compile-path* *e *err* *file* ' +
			'*flush-on-newline* *in* *macro-meta* *math-context* *ns* *out* ' +
			'*print-dup* *print-length* *print-level* *print-meta* *print-readably* ' +
			'*read-eval* *source-path* *use-context-classloader* ' +
			'*warn-on-reflection* + - -> -&gt; ->> -&gt;&gt; .. / < &lt; <= &lt;= = ' +
			'== > &gt; >= &gt;= accessor aclone ' +
			'add-classpath add-watch agent agent-errors aget alength alias all-ns ' +
			'alter alter-meta! alter-var-root amap ancestors and apply areduce ' +
			'array-map aset aset-boolean aset-byte aset-char aset-double aset-float ' +
			'aset-int aset-long aset-short assert assoc assoc! assoc-in associative? ' +
			'atom await await-for await1 bases bean bigdec bigint binding bit-and ' +
			'bit-and-not bit-clear bit-flip bit-not bit-or bit-set bit-shift-left ' +
			'bit-shift-right bit-test bit-xor boolean boolean-array booleans ' +
			'bound-fn bound-fn* butlast byte byte-array bytes cast char char-array ' +
			'char-escape-string char-name-string char? chars chunk chunk-append ' +
			'chunk-buffer chunk-cons chunk-first chunk-next chunk-rest chunked-seq? ' +
			'class class? clear-agent-errors clojure-version coll? comment commute ' +
			'comp comparator compare compare-and-set! compile complement concat cond ' +
			'condp conj conj! cons constantly construct-proxy contains? count ' +
			'counted? create-ns create-struct cycle dec decimal? declare definline ' +
			'defmacro defmethod defmulti defn defn- defonce defstruct delay delay? ' +
			'deliver deref derive descendants destructure disj disj! dissoc dissoc! ' +
			'distinct distinct? doall doc dorun doseq dosync dotimes doto double ' +
			'double-array doubles drop drop-last drop-while empty empty? ensure ' +
			'enumeration-seq eval even? every? false? ffirst file-seq filter find ' +
			'find-doc find-ns find-var first float float-array float? floats flush ' +
			'fn fn? fnext for force format future future-call future-cancel ' +
			'future-cancelled? future-done? future? gen-class gen-interface gensym ' +
			'get get-in get-method get-proxy-class get-thread-bindings get-validator ' +
			'hash hash-map hash-set identical? identity if-let if-not ifn? import ' +
			'in-ns inc init-proxy instance? int int-array integer? interleave intern ' +
			'interpose into into-array ints io! isa? iterate iterator-seq juxt key ' +
			'keys keyword keyword? last lazy-cat lazy-seq let letfn line-seq list ' +
			'list* list? load load-file load-reader load-string loaded-libs locking ' +
			'long long-array longs loop macroexpand macroexpand-1 make-array ' +
			'make-hierarchy map map? mapcat max max-key memfn memoize merge ' +
			'merge-with meta method-sig methods min min-key mod name namespace neg? ' +
			'newline next nfirst nil? nnext not not-any? not-empty not-every? not= ' +
			'	ns ns-aliases ns-imports ns-interns ns-map ns-name ns-publics ' +
			'ns-refers ns-resolve ns-unalias ns-unmap nth nthnext num number? odd? ' +
			'or parents partial partition pcalls peek persistent! pmap pop pop! ' +
			'pop-thread-bindings pos? pr pr-str prefer-method prefers ' +
			'primitives-classnames print print-ctor print-doc print-dup print-method ' +
			'print-namespace-doc print-simple print-special-doc print-str printf ' +
			'println println-str prn prn-str promise proxy proxy-call-with-super ' +
			'proxy-mappings proxy-name proxy-super push-thread-bindings pvalues quot ' +
			'rand rand-int range ratio? rational? rationalize re-find re-groups ' +
			're-matcher re-matches re-pattern re-seq read read-line read-string ' +
			'reduce ref ref-history-count ref-max-history ref-min-history ref-set ' +
			'refer refer-clojure release-pending-sends rem remove remove-method ' +
			'remove-ns remove-watch repeat repeatedly replace replicate require ' +
			'reset! reset-meta! resolve rest resultset-seq reverse reversible? rseq ' +
			'rsubseq second select-keys send send-off seq seq? seque sequence ' +
			'sequential? set set-validator! set? short short-array shorts ' +
			'shutdown-agents slurp some sort sort-by sorted-map sorted-map-by ' +
			'sorted-set sorted-set-by sorted? special-form-anchor special-symbol? ' +
			'split-at split-with str stream? string? struct struct-map subs subseq ' +
			'subvec supers swap! symbol symbol? sync syntax-symbol-anchor take ' +
			'take-last take-nth take-while test the-ns time to-array to-array-2d ' +
			'trampoline transient tree-seq true? type unchecked-add unchecked-dec ' +
			'unchecked-divide unchecked-inc unchecked-multiply unchecked-negate ' +
			'unchecked-remainder unchecked-subtract underive unquote ' +
			'unquote-splicing update-in update-proxy use val vals var-get var-set ' +
			'var? vary-meta vec vector vector? when when-first when-let when-not ' +
			'while with-bindings with-bindings* with-in-str with-loading-context ' +
			'with-local-vars with-meta with-open with-out-str with-precision xml-seq ' +
			'zero? zipmap ';

	this.getKeywords = function (keywordStr) {
		// quote special characters
		keywordStr = keywordStr.replace(/[\-\[\]{}()*+?.\\\^$|,#]/g, "\\$&");
		// trim whitespace and convert to alternatives
		keywordStr = keywordStr.replace(/^\s+|\s+$/g, '').replace(/\s+/g, '|');
		// create pattern
		return '(?:' + keywordStr + ')';
	};

	this.regexList = [
		// comments
		{ regex: new RegExp(';.*$', 'gm'),
			css: 'comments' },
		// strings
		{ regex: SyntaxHighlighter.regexLib.multiLineDoubleQuotedString,
			css: 'string' },
		// regular expressions
		{ regex: /#"(?:\.|(\\\")|[^\""\n])*"/g,
			css: 'string' },
		// vectors
		{ regex: /\[|\]/g,
			css: 'keyword' },
		// amperstands
		{ regex: /&(amp;)?/g,
			css: 'keyword' },
		// sets and maps
		{ regex: /#?\{|\}/g,
			css: 'keyword' },
		// metadata
		{ regex: /#\^\{/g,
			css: 'keyword' },
		// anonymous fn syntactic sugar
		{ regex: /#\(|%/g,
			css: 'keyword' },
		// deref reader macro
		{ regex: /@/g,
			css: 'keyword' },
		// (un)quoted sexprs
		{ regex: /(['`]|~@?)[\[({]/g,
			css: 'keyword' },
		// lists
		{ regex: /\(|\)/g,
			css: 'keyword' },
		// character literals
		{ regex: /\\.\b/g,
			css: 'value' },
		// hexadecimal literals
		{ regex: /[+\-]?\b0x[0-9A-F]+\b/gi,
			css: 'value' },
		// integer/octal/float/bigdecimal literals
		{ regex: new ClojureRegExp("[+-]?\\b\\d+(\\.\\d*)?([eE][+-]?\\d+|M)?\\b"),
			css: 'value' },
		{ regex: /^[+\-]?\b\d+(\.\d*)?([eE][+\-]?\d+|M)?\b/g,
			css: 'value' },
		// booleans+nil
		{ regex: /\b(true|false|nil)\b/g,
			css: 'value' },
		// (un)quoted symbols
		{ regex: /(`|#?'|~@?)[\w-.\/]+/g,
			css: 'color1' },
		// keywords
		{ regex: /:[A-Za-z0-9_\-]+/g,
			css: 'constants' },
		// special forms
		{ regex: new ClojureRegExp(this.getKeywords(special_forms)),
			css: 'preprocessor' },
		// type hints
		{ regex: /\#\^[A-Za-z]\w*/g,
			css: 'preprocessor' },
		// clojure.core
		{ regex: new ClojureRegExp(this.getKeywords(clojure_core)),
			css: 'functions' }
	];

	this.forHtmlScript(SyntaxHighlighter.regexLib.scriptScriptTags);
};

SyntaxHighlighter.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
SyntaxHighlighter.brushes.Clojure.aliases   = ['clojure', 'Clojure', 'clj'];

// vim: ts=2 sw=2 noet
</script><script type="text/javascript">
// hackity-hack

$(document).ready(function() {
    var ft = $("#floating-toc")
    var ul = ft.find('ul')
    var lis = ft.find('li')

    ul.css('maring', '0px')

    var liHeight = $(lis.get(0)).height()

    ft.css('height', (liHeight) + 'px')


    showNs = function(ns) {
        //this is killing performance, lookup table.
        //var el = $("[id='floating-toc_" + ns + "']")
        //var index = lis.index(el)

        var index = 0

        for(i in nsPositions.nss) {
            if(ns == nsPositions.nss[i]) index = i
        }

        console.log(index)

        if(index == lastNsIndex) return;

        lastNsIndex = index


        ul.animate({marginTop: (-1 * liHeight * index) + 'px'},
               300)
        //        ul.css('margin-top', (-1 * liHeight * index) + 'px')

    }

    var calcNsPositions = function() {
        var nss = []
        var anchors = []
        var positions = []
        $.each(lis, function(i, el) {
            var ns = $(el).attr('id').split('_')[1]
            nss.push(ns)
            var a = $("a[name='"+ns+"']")
            anchors.push(a)
            positions.push(a.offset().top)
            console.log(a.offset().top)
        });

        return {nss: nss, positions: positions}
    }

    var nsPositions = calcNsPositions()

    console.log(nsPositions)

    var lastNsIndex = -1

    var $window = $(window)

    var currentSection = function(nsp) {

        var ps = nsp.positions
        var nss = nsp.nss
        var scroll = $window.scrollTop() + 300
        var nsIndex = -1
        for(var i in ps) {
            var p = ps[i]
            if(p >= scroll) {
                nsIndex = i-1
                break;
            }
                
        }

        if(nsIndex == -1 && scroll >= ps[0]) {
            nsIndex = ps.length-1
        }

        if(nsIndex == -1) nsIndex = 0

        return nss[nsIndex]
    }

    $(window).scroll(function(e) {
        showNs(currentSection(nsPositions))
    })

    ul.css('margin-top', '0px')

})
</script><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
  margin: 0 !important;
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .keyword {
  font-weight: bold !important;
}
.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}
</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{font-size:34px;display:inline;}h2.project-version{font-size:18px;margin-top:0;display:inline;margin-left:10px;}.toc-link{font-size:12px;margin-left:10px;color:#252519;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{font-size:34px;margin:0;}.docs-header{border-bottom:dotted #aaa 1px;padding-bottom:10px;margin-bottom:25px;}.toc h1{font-size:24px;}.toc{border-bottom:solid #bbb 1px;margin-bottom:40px;}.toc ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.toc li{list-style-type:none;padding-left:0;}.dependencies{}.dependencies table{font-size:16px;width:99.99%;border:none;margin-left:20px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{margin-left:20px;padding-left:0px;padding-top:0;margin-top:0;}.plugins li{list-style-type:none;padding-left:0;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;top:10px;right:20px;height:20px;overflow:hidden;text-align:right;}#floating-toc li{list-style-type:none;margin:0;padding:0;}</style><style type="text/css">body{margin:0;padding:0;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;font-size:16px;color:#252519;}h1{font-size:20px;margin-top:0;}a.anchor{text-decoration:none;color:#252519;}a.anchor:hover{color:#5050A6;}table{border-spacing:0;border-bottom:solid #ddd 1px;;margin-bottom:10px;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{width:410px;max-width:410px;vertical-align:top;margin:0px;padding-left:55px;padding-right:20px;border:none;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{background-color:ghostWhite;border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><title>pallet -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">pallet</h1><h2 class="project-version">0.4.1-SNAPSHOT</h2><br /><p>Pallet - agile provisioning and configuration of compute nodes. A devops tool.</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.0</td></tr><tr><td class="dep-name">org.clojure/clojure-contrib</td><td class="dotted"><hr /></td><td class="dep-version">1.2.0</td></tr><tr><td class="dep-name">clj-http/clj-http</td><td class="dotted"><hr /></td><td class="dep-version">0.1.1</td></tr><tr><td class="dep-name">clj-ssh/clj-ssh</td><td class="dotted"><hr /></td><td class="dep-version">0.2.0</td></tr><tr><td class="dep-name">log4j/log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.2.14</td></tr><tr><td class="dep-name">jline/jline</td><td class="dotted"><hr /></td><td class="dep-version">0.9.94</td></tr><tr><td class="dep-name">org.cloudhoist/enlive</td><td class="dotted"><hr /></td><td class="dep-version">1.0.0</td></tr><tr><td class="dep-name">org.apache.maven/maven-settings</td><td class="dotted"><hr /></td><td class="dep-version">2.0.10</td></tr><tr><td class="dep-name">vmfest/vmfest</td><td class="dotted"><hr /></td><td class="dep-version">0.2.1-SNAPSHOT</td></tr><tr><td class="dep-name">swank-clojure/swank-clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.2.1</td></tr><tr><td class="dep-name">autodoc/autodoc</td><td class="dotted"><hr /></td><td class="dep-version">0.7.1</td></tr><tr><td class="dep-name">marginalia/marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.5.0-alpha</td></tr><tr><td class="dep-name">org.jclouds/jclouds-compute</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-blobstore</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-aws</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-bluelock</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-gogrid</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-rackspace</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-rimuhosting</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-slicehost</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-terremark</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-jsch</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr><tr><td class="dep-name">org.jclouds/jclouds-enterprise</td><td class="dotted"><hr /></td><td class="dep-version">1.0-beta-8</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#pallet.argument">pallet.argument</a></li><li><a href="#pallet.blobstore.implementation">pallet.blobstore.implementation</a></li><li><a href="#pallet.blobstore.jclouds">pallet.blobstore.jclouds</a></li><li><a href="#pallet.blobstore.url-blobstore">pallet.blobstore.url-blobstore</a></li><li><a href="#pallet.blobstore">pallet.blobstore</a></li><li><a href="#pallet.command-line">pallet.command-line</a></li><li><a href="#pallet.command-script">pallet.command-script</a></li><li><a href="#pallet.compute.implementation">pallet.compute.implementation</a></li><li><a href="#pallet.compute.jclouds">pallet.compute.jclouds</a></li><li><a href="#pallet.compute.jvm">pallet.compute.jvm</a></li><li><a href="#pallet.compute.node-list">pallet.compute.node-list</a></li><li><a href="#pallet.compute.vmfest">pallet.compute.vmfest</a></li><li><a href="#pallet.compute">pallet.compute</a></li><li><a href="#pallet.configure">pallet.configure</a></li><li><a href="#pallet.core">pallet.core</a></li><li><a href="#pallet.debug">pallet.debug</a></li><li><a href="#pallet.enlive">pallet.enlive</a></li><li><a href="#pallet.execute">pallet.execute</a></li><li><a href="#pallet.heynote">pallet.heynote</a></li><li><a href="#pallet.main">pallet.main</a></li><li><a href="#pallet.main-invoker">pallet.main-invoker</a></li><li><a href="#pallet.maven">pallet.maven</a></li><li><a href="#pallet.md5crypt">pallet.md5crypt</a></li><li><a href="#pallet.parameter">pallet.parameter</a></li><li><a href="#pallet.repl">pallet.repl</a></li><li><a href="#pallet.request-map">pallet.request-map</a></li><li><a href="#pallet.resource.directory">pallet.resource.directory</a></li><li><a href="#pallet.resource.exec-script">pallet.resource.exec-script</a></li><li><a href="#pallet.resource.file">pallet.resource.file</a></li><li><a href="#pallet.resource.filesystem">pallet.resource.filesystem</a></li><li><a href="#pallet.resource.filesystem-layout">pallet.resource.filesystem-layout</a></li><li><a href="#pallet.resource.format">pallet.resource.format</a></li><li><a href="#pallet.resource.hostinfo">pallet.resource.hostinfo</a></li><li><a href="#pallet.resource.lib">pallet.resource.lib</a></li><li><a href="#pallet.resource.network-service">pallet.resource.network-service</a></li><li><a href="#pallet.resource.package">pallet.resource.package</a></li><li><a href="#pallet.resource.remote-directory">pallet.resource.remote-directory</a></li><li><a href="#pallet.resource.remote-file">pallet.resource.remote-file</a></li><li><a href="#pallet.resource.resource-when">pallet.resource.resource-when</a></li><li><a href="#pallet.resource.rsync">pallet.resource.rsync</a></li><li><a href="#pallet.resource.service">pallet.resource.service</a></li><li><a href="#pallet.resource.user">pallet.resource.user</a></li><li><a href="#pallet.resource">pallet.resource</a></li><li><a href="#pallet.resource-build">pallet.resource-build</a></li><li><a href="#pallet.script">pallet.script</a></li><li><a href="#pallet.stevedore">pallet.stevedore</a></li><li><a href="#pallet.strint">pallet.strint</a></li><li><a href="#pallet.target">pallet.target</a></li><li><a href="#pallet.task.containers">pallet.task.containers</a></li><li><a href="#pallet.task.converge">pallet.task.converge</a></li><li><a href="#pallet.task.describe-node">pallet.task.describe-node</a></li><li><a href="#pallet.task.feedback">pallet.task.feedback</a></li><li><a href="#pallet.task.help">pallet.task.help</a></li><li><a href="#pallet.task.lift">pallet.task.lift</a></li><li><a href="#pallet.task.new-project">pallet.task.new-project</a></li><li><a href="#pallet.task.nodes">pallet.task.nodes</a></li><li><a href="#pallet.task.providers">pallet.task.providers</a></li><li><a href="#pallet.task.to-blob">pallet.task.to-blob</a></li><li><a href="#pallet.task.version">pallet.task.version</a></li><li><a href="#pallet.template.properties">pallet.template.properties</a></li><li><a href="#pallet.template">pallet.template</a></li><li><a href="#pallet.thread-expr">pallet.thread-expr</a></li><li><a href="#pallet.utils">pallet.utils</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.argument" name="pallet.argument"><h1 class="project-name">pallet.argument</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Arguments to resources.  Adds capability of evaluating arguments at
   resource application</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.argument)</pre></tr><tr><td class="docs"><p>A protocol for passing arguments, with delayed evaluation.</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol DelayedArgument
  (evaluate [x request]))</pre></tr><tr><td class="docs"><p>By default, arguments should evaluate to themeselves</p>
</td><td class="codes" /><pre class="brush: clojure">(extend-type
 Object
 DelayedArgument
 (evaluate [x request] x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype DelayedFunction
  [f]
  DelayedArgument
  (evaluate [_ request] (f request)))</pre></tr><tr><td class="docs"><p>Pass a function with a single argument, to be used to compute an argument at
   resource applicaiton time.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn delayed-fn
  [f]
  (DelayedFunction. f))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro delayed
  "Pass an argument to be evaluated at resource applicaiton time."
  [[request-sym] & body]
  `(DelayedFunction. (fn [~request-sym] ~@body)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.implementation" name="pallet.blobstore.implementation"><h1 class="project-name">pallet.blobstore.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.implementation
  (:require
   [clojure.contrib.find-namespaces :as find-namespaces]))</pre></tr><tr><td class="docs"><p>Instantiate a blobstore. Providers should implement a method for this.
   See pallet.blobstore/blobstore-service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti service
  (fn [provider-name & _] (keyword provider-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def blobstore-regex #"^pallet\.blobstore\.[a-z-]+")
(def exclude-blobstore-ns
  #{'pallet.blobstore.implementation})
(def exclude-regex #".*test.*")
(def provider-list (atom nil))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- providers
  "Find the available providers."
  []
  (try
    (->> (find-namespaces/find-namespaces-on-classpath)
         (filter #(re-find blobstore-regex (name %)))
         (remove #(re-find exclude-regex (name %)))
         (remove exclude-blobstore-ns)
         (set))
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes" /><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable _)))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (->>
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.jclouds" name="pallet.blobstore.jclouds"><h1 class="project-name">pallet.blobstore.jclouds</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>jclouds blobstore implementation</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.jclouds
  (:require
   [org.jclouds.blobstore :as jclouds-blobstore]
   [pallet.blobstore.implementation :as implementation]
   [pallet.compute.jvm :as jvm]))</pre></tr><tr><td class="docs"><p>Default extensions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-jclouds-extensions
  []
  (if (jvm/log4j?)
    [:log4j]
    []))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :default
  [provider {:keys [identity credential extensions]
             :or {identity 
                  credential 
                  extensions (default-jclouds-extensions)}}]
  (apply jclouds-blobstore/blobstore
         provider identity credential extensions))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type org.jclouds.blobstore.BlobStore
  pallet.blobstore/Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   (let [request (jclouds-blobstore/sign-blob-request
                  container path request-map blobstore)]
     {:endpoint (.getEndpoint request)
      :headers (.. request getHeaders entries)}))
  (put-file
   [blobstore container path file]
   (when-not (jclouds-blobstore/container-exists? container blobstore)
     (jclouds-blobstore/create-container container nil blobstore))
   (jclouds-blobstore/upload-blob
    container path (java.io.File. file) blobstore))
  (containers [blobstore] (jclouds-blobstore/containers blobstore))
  (close [blobstore] (.. blobstore getContext close)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore.url-blobstore" name="pallet.blobstore.url-blobstore"><h1 class="project-name">pallet.blobstore.url-blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A url based blobstore implementation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore.url-blobstore
  (:require
   [pallet.blobstore :as blobstore]
   [pallet.blobstore.implementation :as implementation]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord UrlBlobstore
    [base-url]
  pallet.blobstore/Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   {:endpoint (format "%s/%s/%s" base-url container path)
    :headers nil})
  (close
   [blobstore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :url-blobstore
  [provider {:keys [base-url]
             :or {base-url "http://localhost"}}]
  (UrlBlobstore. base-url))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.blobstore" name="pallet.blobstore"><h1 class="project-name">pallet.blobstore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Blobstore abstraction</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.blobstore
  (:require
   [pallet.blobstore.implementation :as implementation]
   [pallet.configure :as configure]))</pre></tr><tr><td class="docs"><p>Instantiate a blobstore service based on the given arguments</p>

<p>Compute Service instantiation</p>
</td><td class="codes" /><pre class="brush: clojure">(defn service
  [provider-name
   & {:keys [identity credential extensions] :as options}]
  (implementation/load-providers)
  (implementation/service provider-name options))</pre></tr><tr><td class="docs"><p>Translate compute provider to associated blobstore provider</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc }
  blobstore-lookup
  {"cloudservers" "cloudfiles"
   "ec2" "s3"})</pre></tr><tr><td class="docs"><p>Create a blobstore service from a credentials map.
   Uses :provider, :identity, :credential and
   :blobstore-provider, :blobstore-identity and :blobstore-credential.
   Blobstore keys fall back to the compute keys</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-map
  [credentials]
  (when-let [provider (or (:blobstore-provider credentials)
                          (blobstore-lookup (:provider credentials)))]
    (service
     provider
     :identity (or (:blobstore-identity credentials)
                   (:identity credentials))
     :credential (or (:blobstore-credential credentials)
                     (:credential credentials)))))</pre></tr><tr><td class="docs"><p>Create a blobstore service from ~/.m2/settings.xml propery settings.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-settings
  [& profiles]
  (try
    (require 'pallet.maven) ; allow running without maven jars
    (when-let [f (ns-resolve 'pallet.maven 'credentials)]
      (blobstore-from-map (f profiles)))
    (catch ClassNotFoundException _)
    (catch clojure.lang.Compiler$CompilerException _)))</pre></tr><tr><td class="docs"><p>Create a blobstore service form a configuration map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn blobstore-from-config
  [config profiles]
  (let [config (configure/compute-service-properties config profiles)
        {:keys [provider identity credential]} (merge
                                                (update-in
                                                 config [:provider]
                                                 (fn [p]
                                                   (blobstore-lookup p)))
                                                (:blobstore config))]
    (when provider
      (service provider :identity identity :credential credential))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Blobstore
  (sign-blob-request
   [blobstore container path request-map]
   "Create a signed request")
  (put-file
   [blobstore container path file]
   "Upload a file")
  (containers
   [blobstore]
   "List containers")
  (close
   [blobstore]
   "Close the blobstore"))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.command-line" name="pallet.command-line"><h1 class="project-name">pallet.command-line</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Taken from clojure.contrib</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>Process command-line arguments according to a given cmdspec</p>
</td><td class="codes" /><pre class="brush: clojure">(ns #^{:author "Chris Houser"}
    pallet.command-line
  (:refer-clojure :exclude [group-by]))</pre></tr><tr><td class="docs"><p>Returns a string of all elements in coll, separated by
  separator.  Like Perl's join.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn #^String join
  [#^String separator coll]
  (apply str (interpose separator coll)))</pre></tr><tr><td class="docs"><p>Returns a sorted map of the elements of coll keyed by the result of
  f on each element. The value at each key will be a vector of the
  corresponding elements, in the order they appeared in coll.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn group-by ;; in clojure 1.2 core
  [f coll]
  (reduce
   (fn [ret x]
     (let [k (f x)]
       (assoc ret k (conj (get ret k []) x))))
   (sorted-map) coll))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-map [args cmdspec]
  (let [{spec true [rest-sym] false} (group-by vector? cmdspec)
        rest-str (str rest-sym)
        key-data (into {} (for [[syms [_ default]] (map #(split-with symbol? %)
                                                        (conj spec '[help? h?]))
                                sym syms]
                            [(re-find #"^.*[^?]" (str sym))
                             {:sym (str (first syms)) :default default}]))
        defaults (into {} (for [[_ {:keys [default sym]}] key-data
                                :when default]
                            [sym default]))]
    (loop [[argkey & [argval :as r]] args
           cmdmap (assoc defaults :cmdspec cmdspec rest-str [])]
      (if argkey
        (let [[_ & [keybase]] (re-find #"^--?(.*)" argkey)]
          (cond
            (= keybase nil) (recur r (update-in cmdmap [rest-str] conj argkey))
            (= keybase )  (update-in cmdmap [rest-str] #(apply conj % r))
            :else (if-let [found (key-data keybase)]
                    (if (= \? (last (:sym found)))
                      (recur r (assoc cmdmap (:sym found) true))
                      (recur (next r) (assoc cmdmap (:sym found)
                                             (if (or (nil? r) (= \- (ffirst r)))
                                               (:default found)
                                               (first r)))))
                    (throw (Exception. (str "Unknown option " argkey))))))
        cmdmap))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- align
   "Align strings given as vectors of columns, with first vector
   specifying right or left alignment (:r or :l) for each column."
   [spec & rows]
   (let [maxes (vec (for [n (range (count (first rows)))]
                      (apply max (map (comp count #(nth % n)) rows))))
         fmt (join " "
                   (for [n (range (count maxes))]
                     (str "%"
                          (when-not (zero? (maxes n))
                            (str (when (= (spec n) :l) "-") (maxes n)))
                          "s")))]
     (join "\n"
           (for [row rows]
             (apply format fmt row)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- rmv-q
   "Remove ?"
   [#^String s]
   (if (.endsWith s "?")
      (.substring s 0 (dec (count s)))
      s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn print-help [desc cmdmap]
  (println desc)
  (println "Options")
  (println
     (apply align [:l :l :l]
        (for [spec (:cmdspec cmdmap) :when (vector? spec)]
            (let [[argnames [text default]] (split-with symbol? spec)
                  [_ opt q] (re-find #"^(.*[^?])(\??)$"
                                 (str (first argnames)))
                  argnames  (map (comp rmv-q str) argnames)
                  argnames
                        (join ", "
                          (for [arg argnames]
                            (if (= 1 (count arg))
                              (str "-" arg)
                              (str "--" arg))))]
               [(str "  " argnames (when (=  q) " <arg>") " ")
                text
                (if-not default
                  (str " [default " default "]"))])))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-command-line
  "Bind locals to command-line args."
  [args desc cmdspec & body]
  (let [locals (vec (for [spec cmdspec]
                      (if (vector? spec)
                        (first spec)
                        spec)))]
    `(let [{:strs ~locals :as cmdmap#} (make-map ~args '~cmdspec)]
       (if (cmdmap# "help?")
         (print-help ~desc cmdmap#)
         (do ~@body)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(comment

; example of usage:

(with-command-line *command-line-args*
  "tojs -- Compile ClojureScript to JavaScript"
  [[simple? s? "Runs some simple built-in tests"]
   [serve      "Starts a repl server on the given port" 8081]
   [mkboot?    "Generates a boot.js file"]
   [verbose? v? "Includes extra fn names and comments in js"]
   filenames]
  (binding [*debug-fn-names* verbose? *debug-comments* verbose?]
    (cond
      simple? (simple-tests)
      serve   (start-server (Integer/parseInt serve))
      mkboot? (mkboot)
      :else   (doseq [filename filenames]
                 (filetojs filename)))))

)</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.command-script" name="pallet.command-script"><h1 class="project-name">pallet.command-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Produce a shell script for launching Pallet, possibly customised for extra jars</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.command-script
  (:require
   [pallet.stevedore :as stevedore]
   [pallet.resource.user :as user]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn path
  [components]
  (apply str (interpose "/" components)))</pre></tr><tr><td class="docs"><p>normalize $0 on certain BSDs</p>
</td><td class="codes" /><pre class="brush: clojure">(defn normalize-scriptname
  []
  (stevedore/script
   (if (= @(dirname $0) ".")
     (defvar SCRIPT "$(which $(basename $0))")
     (defvar SCRIPT "$0"))))</pre></tr><tr><td class="docs"><p>resolve symlinks to the script itself portably</p>
</td><td class="codes" /><pre class="brush: clojure">(defn resolve-symlinks
  []
  (stevedore/script
   (while (symlink? @SCRIPT)
          (defvar ls @(ls -ld (quoted @SCRIPT)))
          (defvar link @(expr (quoted @ls) ":" "'.*-> \\(.*\\)$'"))
          (if (expr (quoted @link) ":" "'/.*'" > "/dev/null")
            (defvar SCRIPT (quoted @link))
            (defvar SCRIPT (quoted (str @(dirname @SCRIPT) "/" @link)))))
   (defvar BIN_DIR (quoted @(dirname (quoted @SCRIPT))))))</pre></tr><tr><td class="docs"><p>Script to set HTTP client options.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn http-client
  []
  (stevedore/script
   (defvar HTTP_CLIENT (quoted "wget "))
   (defvar HTTP_OUTFILE (quoted "-O "))
   (defvar HTTP_STDOUT (quoted "-q -O - "))
   (if (type -p curl ">/dev/null 2>&1")
     (do
       (defvar HTTP_CLIENT (quoted "curl -L "))
       (defvar HTTP_OUTFILE (quoted "-o "))
       (defvar HTTP_STDOUT (quoted ""))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-snapshot-path
  [artifacts]
  (stevedore/script
   (defn snapshot-path [version metafile base_path]
     (defvar METADATA
       @(@HTTP_CLIENT @HTTP_STDOUT @metafile))
     (defvar JARDATE
       @(pipe
         (echo @META)
         (egrep (quoted "[0-9]{8}\\.[0-9]{6}") -o)))
     (defvar JARBUILD
       @(pipe
         (echo @META)
         (fgrep "buildNumber")
         (egrep (quoted "[0-9]+") -o)))
     (defvar JARVERSION
       ~(.replace (:version (first artifacts)) "-SNAPSHOT" ))
     (println (str @base_path @JARVERSION "-" @JARDATE "-" @JARBUILD ".jar")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Artifact
  (local-path [x] "Local path for installing the artifact")
  (remote-path [x] "Remote path for downloading the artifact")
  (jar-name [x] "jar name for the artifact"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord MavenArtifact
  [group-id artifact-id version repository]
  Artifact
  (local-path
   [artifact]
   (path [(stevedore/script @repo) (.replace group-id "." "/") artifact-id version
          (jar-name artifact)]))
  (remote-path
   [artifact]
   (if (.contains version "SNAPSHOT")
     (let [metafile (path [repository (.replace group-id "." "/") artifact-id version
                           "maven-metadata.xml"])]
       (stevedore/script
        @(snapshot-path
          ~version
          ~metafile
          ~(path [repository group-id (.replace group-id "." "/") version
                  (str artifact-id "-")]))))
     (path [repository (.replace group-id "." "/") artifact-id version
            (jar-name artifact)])))
  (jar-name
   [_]
   (str artifact-id "-" version ".jar")))</pre></tr><tr><td class="docs"><p>Return a script fragment setting $repo to the local maven repository path</p>
</td><td class="codes" /><pre class="brush: clojure">(defn m2-repository-path
  []
  (stevedore/script
   (defvar settings (str @HOME "/.m2/settings.xml"))
   (defvar default_repo (str @HOME "/.m2/repository"))
   (if (file-exists? @settings)
     (do
       (defvar repo
         @(chain-or
           (group
            (pipe
             (cat @settings)
             (tr -d "'\n\t '")
             (egrep -o (quoted "<localRepository>(.*)</localRepository>"))
             (sed -e (quoted "s%\\${user.home}%${HOME}%")
                  -e (quoted "s%<localRepository>%%")
                  -e (quoted "s%</localRepository>%%"))))
           (println @default_repo)))
       (if (= @repo "")
         (defvar repo @default_repo)))
     (defvar repo (str @user-home "/.m2/repository")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn download-artifact
  [artifact]
  (stevedore/script
   (@HTTP_CLIENT $HTTP_OUTFILE
                 (quoted ~(local-path artifact))
                 (quoted ~(remote-path artifact)))))</pre></tr><tr><td class="docs"><p>Produces a function to unconditionaly download artifacts</p>
</td><td class="codes" /><pre class="brush: clojure">(defn defn-download
  [artifacts]
  (stevedore/script
   (defn do-download []
     ~(apply stevedore/checked-commands
       "Downloading dependencies"
       (map download-artifact artifacts)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-install
  []
  (stevedore/script
   (defn do-install []
     (do-download)
     (exit 0))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn defn-upgrade
  [artifacts]
  (stevedore/script
   (defn do-upgrade []
     (if-not (writeable? $SCRIPT)
       (do
         (println "You do not have permission to upgrade the installation in "
                  @SCRIPT)
         (exit 1)))
     (echo
      "The script at " @SCRIPT " will be upgraded to the latest stable version.")
     (echo -n "Do you want to continue [Y/n]? ")
     (read RESPONSE)
     (case @RESPONSE
         "y|Y|\"\ (do
                      (println)
                      (println "Upgrading...")
                      (defvar BRANCH
                        ~(if (.contains (:version (first artifacts)) "SNAPSHOT")
                           "master"
                           "stable"))
                      (defvar PALLET_SCRIPT_URL
                        (quoted
                         (str "http://github.com/hugoduncan/pallet/raw/"
                              @BRANCH
                              "/bin/pallet")))
                      (chain-and
                       (@HTTP_CLIENT
                        $HTTP_OUTFILE
                        (quoted @SCRIPT) (quoted @PALLET_SCRIPT_URL))
                       ("chmod" +x (quoted @SCRIPT))
                       (println)
                       (@SCRIPT self-install)
                       (println)
                       (println "Now running" @(@SCRIPT version)))
                      (exit "$?"))
         * (do
             (println "Aborted")
             (exit 1))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn run-from-checkout
  []
  (stevedore/script
   (defvar PALLET_DIR
     (quoted @(dirname (quoted @BIN_DIR))))
   (defvar PALLET_LIBS
     (quoted
      @(pipe
        (find -H (str @PALLET_DIR "/lib") -mindepth 1 -maxdepth 1 -print0
              "2> /dev/null")
        (tr "\\\\0" "\\:"))))
   (defvar CLASSPATH
     (quoted (str (str @PALLET_DIR "/src") ":" (str @PALLET_DIR "/pallet/src") ":" @PALLET_LIBS ":" @CLASSPATH)))
   (defvar BOOTPATH (quoted ))
   (if (&& (= @PALLET_LIBS ) (!= "$1" "self-install" ))
     (do
       (println "Your Pallet development checkout is missing its dependencies.")
       (println "Please use you maven or lein to download the dependencies.")
       (println (quoted "   cd " @PALLET_DIR))
       (println (quoted " and either:"))
       (println (quoted "   lein deps"))
       (println (quoted "   mvn -Dmaven.test.skip=true assembly:directory"))
       (exit 1)))))</pre></tr><tr><td class="docs"><p>We want to run from the first of:
nested pallet project
current project
mvn repo</p>
</td><td class="codes" /><pre class="brush: clojure">(defn run-from-jar
  [artifacts]
  (stevedore/script
   (if (readable? (str "./pallet/lib/" ~(jar-name (first artifacts)) ))
     (do
       (defvar PALLET_LIBS
         (quoted
          @(pipe
            (find -H "./pallet/lib/" -mindepth 1 -maxdepth 1 -print0
                  "2> /dev/null")
            (tr "\\\\0" "\\:"))))
       (defvar CLASSPATH
         (quoted (str @PALLET_LIBS ":./pallet/src/:" @CLASSPATH)))
       (defvar BOOTPATH (quoted )))
     (if (readable? (str "./lib/" ~(jar-name (first artifacts)) ))
       (do
         (defvar PALLET_LIBS
         (quoted
          @(pipe
            (find -H "./lib/" -mindepth 1 -maxdepth 1 -print0 "2> /dev/null")
            (tr "\\\\0" "\\:"))))
         (defvar CLASSPATH
           (quoted (str @PALLET_LIBS ":./pallet/src/:" @CLASSPATH)))
         (defvar BOOTPATH (quoted )))
       (do
         (defvar CLASSPATH
           (quoted
            (str
             ~(apply
               str (interpose ":" (map local-path artifacts)))
             ":" @CLASSPATH))))))
   (defvar BOOTPATH (quoted ))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn paths-for-cygwin
  []
  (stevedore/script
   (when (type -p cygpath ">/dev/null 2>&1")
     (defvar CLOJURE_JAR
       @(cygpath -w (quoted @CLOJURE_JAR)))
     (defvar CLASSPATH
       @(cygpath -w (quoted @CLASSPATH))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn process-commands
  [artifacts]
  (stevedore/script
   (if (= "$1" "self-install")
     (do-install))
   (if (= "$1" "upgrade")
     (do-upgrade))
   (if (readable? (str @BIN_DIR "/../src/pallet/core.clj"))
     (do ~(run-from-checkout))
     (do ~(run-from-jar artifacts)))
   ~(paths-for-cygwin)
   (if "[ $DEBUG ]"
     (println @CLASSPATH))
   (exec
    @RLWRAP
    java -client @JAVA_OPTS -cp (quoted @CLASSPATH)
    (str "-Dpallet.version=" ~(:version (first artifacts)))
    @JLINE
    clojure.main -e (quoted "(use 'pallet.main)(-main)")
    "/dev/null"
    "$@")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn command-script
  [pallet-version artifacts]
  (stevedore/do-script
   "#!/usr/bin/env bash"
   (normalize-scriptname)
   (resolve-symlinks)
   (http-client)
   (m2-repository-path)
   (defn-snapshot-path artifacts)
   (defn-download artifacts)
   (defn-upgrade artifacts)
   (defn-install)
   (process-commands artifacts)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def clojars-repo "http://clojars.org/repo")
(def clojure-release-repo "http://build.clojure.org/releases/")
(def clojure-snapshot-repo "http://build.clojure.org/snapshots")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn write-script
  []
  (println
   (command-script
    "0.0.1-SNAPSHOT"
    [(MavenArtifact. "pallet" "pallet" "0.0.1-SNAPSHOT" clojars-repo)
     (MavenArtifact. "org.clojure" "clojure" "1.2.0-master-SNAPSHOT"
                     clojure-snapshot-repo)])))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.implementation" name="pallet.compute.implementation"><h1 class="project-name">pallet.compute.implementation</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Implementation details</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.implementation
  (:require
   [clojure.contrib.find-namespaces :as find-namespaces]))</pre></tr><tr><td class="docs"><p>Instantiate a compute service. Providers should implement a method for this.
   See pallet.compute/compute-service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti service
  (fn [provider-name & _] (keyword provider-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def compute-regex #"^pallet\.compute\.[a-z-]+")
(def exclude-compute-ns
  #{'pallet.compute.jvm
    'pallet.compute.implementation})
(def exclude-regex #".*test.*")
(def provider-list (atom nil))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- providers
  "Find the available providers."
  []
  (try
    (->> (find-namespaces/find-namespaces-on-classpath)
         (filter #(re-find compute-regex (name %)))
         (remove #(re-find exclude-regex (name %)))
         (remove exclude-compute-ns)
         (set))
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs"><p>Require all providers, ensuring no errors if individual providers can not be
   loaded</p>
</td><td class="codes" /><pre class="brush: clojure">(defn load-providers
  []
  (when-not @provider-list
    (reset! provider-list (providers))
    (let [loaded (filter
                  identity
                  (doall
                   (for [provider @provider-list]
                     (try
                       (require provider)
                       provider
                       (catch Throwable _)))))]
      (reset! provider-list loaded)))
  @provider-list)</pre></tr><tr><td class="docs"><p>Create a list of supported providers</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (->>
   (doall
    (for [provider (load-providers)]
      (when-let [providers (ns-resolve provider 'supported-providers)]
        (@providers))))
   (filter identity)
   (apply concat)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.jclouds" name="pallet.compute.jclouds"><h1 class="project-name">pallet.compute.jclouds</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>jclouds compute service implementation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.jclouds
  (:require
   [org.jclouds.compute :as jclouds]
   [pallet.compute.implementation :as implementation]
   [pallet.compute.jvm :as jvm]
   [pallet.compute :as compute]
   [pallet.resource :as resource]
   [pallet.script :as script]
   [pallet.target :as target]
   [pallet.utils :as utils]
   [pallet.execute :as execute]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging])
  (:import
   [org.jclouds.compute.domain.internal NodeMetadataImpl ImageImpl HardwareImpl]
   org.jclouds.compute.util.ComputeServiceUtils
   org.jclouds.compute.ComputeService
   [org.jclouds.compute.domain
    NodeState NodeMetadata Image OperatingSystem OsFamily Hardware]
   org.jclouds.domain.Location))</pre></tr><tr><td class="docs"><p>Meta</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  (ComputeServiceUtils/getSupportedProviders))</pre></tr><tr><td class="docs"><p>Default extensions</p>

<p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-jclouds-extensions
  [provider]
  (concat
   (if (jvm/log4j?) [:log4j] [])
   (if (= (name provider) "stub")
     (try
       (require 'pallet.compute.jclouds-ssh-test)
       (when-let [f (ns-resolve
                     'pallet.compute.jclouds-ssh-test 'ssh-test-client)]
         [(f (ns-resolve 'pallet.compute.jclouds-ssh-test 'no-op-ssh-client))])
       (catch java.io.FileNotFoundException _))
     [:ssh])))</pre></tr><tr><td class="docs"><p>translate option names</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true :doc }
  option-keys
  {:endpoint :jclouds.endpoint})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn option-key
  [provider key]
  (case key
    :endpoint (keyword (format (str provider ".endpoint")))
    (option-keys key key)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :default
  [provider {:keys [identity credential extensions endpoint]
             :or {extensions (default-jclouds-extensions provider)}
             :as options}]
  (logging/info (format "extensions %s" (pr-str extensions)))
  (let [options (dissoc options :identity :credential :extensions :blobstore)]
    (apply
     jclouds/compute-service
     (name provider) identity credential
     :extensions extensions
     (interleave
      (map #(option-key provider %) (keys options))
      (vals options)))))</pre></tr><tr><td class="docs"><p>Node utilities</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-operating-system
  [{:keys [family name version arch description is-64bit]
    :or {family OsFamily/UBUNTU
         name "Ubuntu"
         version "Some version"
         arch "Some arch"
         description "Desc"
         is-64bit true}}]
  (OperatingSystem. family name version arch description is-64bit))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-family-map
  {"AIX" OsFamily/AIX
   "ARCH" OsFamily/ARCH
   "Mac OS" OsFamily/DARWIN
   "Mac OS X" OsFamily/DARWIN
   "FreeBSD" OsFamily/FREEBSD
   "HP UX" OsFamily/HPUX
   "Linux"   OsFamily/UBUNTU ;; guess for now
   "Solaris" OsFamily/SOLARIS
   "Windows 2000" OsFamily/WINDOWS
   "Windows 7" OsFamily/WINDOWS
   "Windows 95" OsFamily/WINDOWS
   "Windows 98" OsFamily/WINDOWS
   "Windows NT" OsFamily/WINDOWS
   "Windows Vista" OsFamily/WINDOWS
   "Windows XP" OsFamily/WINDOWS})</pre></tr><tr><td class="docs"><p>Create an OperatingSystem object for the local host</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-operating-system
  []
  (let [os-name (System/getProperty "os.name")]
    (make-operating-system
     {:family (or (jvm-os-family-map (jvm/os-name)) OsFamily/UNRECOGNIZED)
      :name os-name
      :description os-name
      :version (System/getProperty "os.version")
      :arch (System/getProperty "os.arch")
      :is-64bit (= "64" (System/getProperty "sun.arch.data.model"))})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-hardware
  [{:keys [provider-id name id location uri user-metadata processors ram
           volumes supports-image]
    :or {provider-id "provider-hardware-id"
         name "Some Hardware"
         id "Some id"
         user-metadata {}
         processors []
         ram 512
         volumes []
         supports-image (fn [&] true)}}]
  (HardwareImpl.
   provider-id name id location uri user-metadata processors ram volumes
   (reify com.google.common.base.Predicate
     (apply [_ i] (supports-image i))
     (equals [_ i] (= supports-image i)))))</pre></tr><tr><td class="docs"><p>Create an Hardware object for the local host</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-hardware
  []
  (let [os-name (System/getProperty "os.name")]
    (make-hardware {})))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-node [tag & options]
  (let [options (apply hash-map options)]
    (NodeMetadataImpl.
     (options :provider-id (options :id tag))
     (options :name tag)                ; name
     (options :id tag)                   ; id
     (options :location)
     (java.net.URI. tag)                ; uri
     (options :user-metadata {})
     tag
     (if-let [hardware (options :hardware)]
       (if (map? hardware) (make-hardware hardware) hardware)
       (make-hardware {}))
     (options :image-id)
     (if-let [os (options :operating-system)]
       (if (map? os) (make-operating-system os) os)
       (make-operating-system {}))
     (options :state NodeState/RUNNING)
     (options :login-port 22)
     (options :public-ips [])
     (options :private-ips [])
     (options :admin-password)
     (options :credentials nil))))</pre></tr><tr><td class="docs"><p>Make a node that is not created by pallet's node management.
   This can be used to manage configuration of any machine accessable over
   ssh, including virtual machines.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-unmanaged-node
  [tag host-or-ip & options]
  (let [options (apply hash-map options)
        meta (dissoc options :location :user-metadata :state :login-port
                     :public-ips :private-ips :extra :admin-password
                     :credentials)]
    (NodeMetadataImpl.
     (options :provider-id (options :id tag))
     (options :name tag)
     (options :id (str tag (rand-int 65000)))
     (options :location)
     (java.net.URI. tag)                ; uri
     (merge (get options :user-metadata {}) meta)
     tag
     (if-let [hardware (options :hardware)]
       (if (map? hardware) (make-hardware hardware) hardware)
       (make-hardware {}))
     (options :image-id)
     (if-let [os (options :operating-system)]
       (if (map? os) (make-operating-system os) os)
       (make-operating-system {}))
     (get options :state NodeState/RUNNING)
     (options :login-port 22)
     (conj (get options :public-ips []) host-or-ip)
     (options :private-ips [])
     (options :admin-password)
     (options :credentials nil))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn make-image
  [id & options]
  (let [options (apply hash-map options)
        meta (dissoc options :name :location :uri :user-metadata
                     :version :operating-system :default-credentials
                     :description)]
    (ImageImpl.
     id ; providerId
     (options :name)
     id
     (options :location)
     (options :uri)
     (merge (get options :user-metadata {}) meta)
     (options :operating-system)
     (options :description "image description")
     (options :version "image version")
     (options :admin-password)
     (options :default-credentials))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn compute-node? [object]
  (instance? NodeMetadata object))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type org.jclouds.compute.domain.NodeMetadata
  pallet.compute/Node

  (ssh-port
    [node]
    (let [md (into {} (.getUserMetadata node))
          port (:ssh-port md)]
      (if port (Integer. port))))

  (primary-ip [node] (first (jclouds/public-ips node)))
  (private-ip [node] (first (jclouds/private-ips node)))
  (is-64bit? [node] (.. node getOperatingSystem is64Bit))
  (tag [node] (jclouds/tag node))

  (os-family
    [node]
    (when-let [operating-system (.getOperatingSystem node)]
      (keyword (str (.getFamily operating-system)))))

  (os-version
    [node]
    (when-let [operating-system (.getOperatingSystem node)]
      (.getVersion operating-system)))

  (hostname [node] (.getName node))
  (id [node] (.getId node))
  (running? [node] (jclouds/running? node))
  (terminated? [node] (jclouds/terminated? node)))</pre></tr><tr><td class="docs"><p>Build the template for specified target node and compute context</p>
</td><td class="codes" /><pre class="brush: clojure">(defn build-node-template
  [compute public-key-path request init-script]
  {:pre [(map? (:node-type request))]}
  (logging/info
   (str "building node template for " (-> request :node-type :tag)))
  (when public-key-path
    (logging/info (str "  authorizing " public-key-path)))
  (when init-script
    (logging/debug (str "  init script\n" init-script)))
  (let [options (-> request :node-type :image)
        options (if (-> request :node-type :default-os-family)
                  (dissoc options :os-family) ; remove if we added in
                                              ; ensure-os-family
                  options)]
    (logging/info (str "  options " options))
    (let [options (if (and public-key-path
                           (not (:authorize-public-key options)))
                    (assoc options
                      :authorize-public-key (slurp public-key-path))
                    options)
          options (if (not (:run-script options))
                    (if init-script
                      (assoc options :run-script (.getBytes init-script))
                      options)
                    options)]
      (jclouds/build-template compute options))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type org.jclouds.compute.ComputeService
  pallet.compute/ComputeService

  (nodes [compute] (jclouds/nodes-with-details compute))

  (ensure-os-family
   [compute request]
   (if (-> request :node-type :image :os-family)
     request
     (let [template (jclouds/build-template
                     (:compute request)
                     (-> request :node-type :image))
           family (-> (.. template getImage getOperatingSystem getFamily)
                      str keyword)]
       (logging/info (format "Default OS is %s" (pr-str family)))
       (when (or (nil? family) (= family OsFamily/UNRECOGNIZED))
         (condition/raise
          :type :unable-to-determine-os-type
          :message (format
                    (str "jclouds was unable to determine the os-family "
                         "of the template %s")
                    (pr-str (-> request :node-type :image)))))
       (->
        request
        (assoc-in [:node-type :image :os-family] family)
        (assoc-in [:node-type :default-os-family] true)))))

  (run-nodes
   [compute node-type node-count request init-script]
   (jclouds/run-nodes
    (name (node-type :tag))
    node-count
    (build-node-template
     compute
     (-> request :user :public-key-path)
     request
     init-script)
    compute))

  (reboot
   [compute nodes]
   (doseq [node nodes]
     (jclouds/reboot-node node compute)))

  (boot-if-down
   [compute nodes]
   (map #(jclouds/reboot-node % compute)
        (filter jclouds/terminated? nodes)))

  (shutdown-node
   [compute node user]
   (let [ip (compute/primary-ip node)]
     (if ip
       (execute/remote-sudo ip "shutdown -h 0" user))))

  (shutdown
   [compute nodes user]
   (doseq [node nodes]
     (compute/shutdown-node compute node user)))

  (destroy-nodes-with-tag
    [compute tag-name]
    (jclouds/destroy-nodes-with-tag (name tag-name) compute))

  (destroy-node
   [compute node]
   (jclouds/destroy-node (compute/id node) compute))

  (close [compute] (.. compute getContext close)))</pre></tr><tr><td class="docs"><p>Return locations of a node as a seq.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn node-locations
  [#^NodeMetadata node]
  (letfn [(loc [#^Location l]
               (when l (cons l (loc (.getParent l)))))]
    (loc (.getLocation node))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn image-string
  [#^Image image]
  (when image
    (let [name (.getName image)
          description (.getDescription image)]
      (format "%s %s %s %s"
              (.getFamily (.getOperatingSystem image))
              (.getArch (.getOperatingSystem image))
              name
              (if (= name description)  description)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-string
  [#^OperatingSystem os]
  (when os
    (let [name (.getName os)
          description (.getDescription os)]
      (format "%s %s %s %s"
              (.getFamily os)
              (.getArch os)
              name
              (if (= name description)  description)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn location-string
  [#^Location location]
  (when location
    (format "%s/%s" (.getScope location) (.getId location))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method Location
  [location writer]
  (.write writer (location-string location)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method NodeMetadata
  [node writer]
  (.write
   writer
   (format
    "%14s\t %s %s\n\t\t %s\n\t\t %s\n\t\t public: %s  private: %s"
    (jclouds/node-tag node)
    (apply str (interpose "." (map location-string (node-locations node))))
    (let [location (.getLocation node)]
      (when (and location (not (= (.getDescription location) (.getId location))))
        (.getDescription location)))
    (os-string (.getOperatingSystem node))
    (.getState node)
    (apply
     str (interpose ", " (.getPublicAddresses node)))
    (apply
     str (interpose ", " (.getPrivateAddresses node))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-map
     { "Mac OS X" :os-x })</pre></tr><tr><td class="docs"><p>Make a node representing the local host</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-localhost-node
  []
  (make-node "localhost"
             :public-ips ["127.0.0.1"]
             :operating-system (local-operating-system)))</pre></tr><tr><td class="docs"><p>Create a request map for localhost</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-request
  []
  (let [node (make-localhost-node)]
    {:target-node node
     :all-nodes [node]
     :target-nodes [node]
     :node-type {:image [(get jvm-os-map (System/getProperty "os.name"))]}}))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.jvm" name="pallet.compute.jvm"><h1 class="project-name">pallet.compute.jvm</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Information from local jvm</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.jvm)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jvm-os-map
  {"Mac OS X" :os-x})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-name []
  (System/getProperty "os.name"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn os-family []
  (or (jvm-os-map (os-name)) :ubuntu))</pre></tr><tr><td class="docs"><p>Predicate to test for log4j on the classpath.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn log4j?
  []
  (try
    (import org.apache.log4j.Logger)
    true
    (catch java.lang.ClassNotFoundException _
      false)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.node-list" name="pallet.compute.node-list"><h1 class="project-name">pallet.compute.node-list</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A simple node list provider</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.node-list
  (:require
   [pallet.compute :as compute]
   [pallet.compute.jvm :as jvm]
   [pallet.compute.implementation :as implementation]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  ["node-list"])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord Node
    [name tag ip os-family os-version id ssh-port private-ip is-64bit running]
  pallet.compute.Node
  (ssh-port [node] ssh-port)
  (primary-ip [node] ip)
  (private-ip [node] private-ip)
  (is-64bit? [node] (:is-64bit node))
  (tag [node] tag)
  (running? [node] running)
  (terminated? [node] (not running))
  (os-family [node] os-family)
  (os-version [node] os-version)
  (hostname [node] name)
  (id [node] id))</pre></tr><tr><td class="docs"><p>Node utilities</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-node [name tag ip os-family
                 & {:keys [id ssh-port private-ip is-64bit running os-version]
                    :or {ssh-port 22 is-64bit true running true}
                    :as options}]
  (Node.
   name
   tag
   ip
   os-family
   os-version
   (or id (str name "-" (string/replace ip #"\." "-")))
   ssh-port
   private-ip
   is-64bit
   running))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord NodeList [node-list]
  pallet.compute.ComputeService
  (nodes [compute-service] node-list)
  (ensure-os-family
   [compute-service request]
   (when (not (-> request :node-type :image :os-family))
     (condition/raise
      :type :no-os-family-specified
       :message "Node list contains a node without os-family")))
  ;; Not implemented
  ;; (build-node-template)
  ;; (run-nodes [node-type node-count request init-script])
  ;; (reboot "Reboot the specified nodes")
  (boot-if-down [compute nodes] nil)
  ;; (shutdown-node "Shutdown a node.")
  ;; (shutdown "Shutdown specified nodes")
  (close [compute]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method Node
  [^Node node writer]
  (.write
   writer
   (format
    "%14s\t %s %s public: %s  private: %s  %s"
    (:tag node)
    (:os-family node)
    (:running node)
    (:ip node)
    (:private-ip node)
    (:id node))))</pre></tr><tr><td class="docs"><p>Make a node representing the local host</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-localhost-node
  [& {:keys [name tag ip os-family id]
      :or {name "localhost"
           tag "local"
           ip "127.0.0.1"
           os-family (jvm/os-family)}
      :as options}]
  (apply
   make-node name tag ip os-family
   (apply concat (merge {:id "localhost"} options))))</pre></tr><tr><td class="docs"><p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :node-list
  [_ {:keys [node-list]}]
  (NodeList.
   (vec
    (map
     #(if (vector? %)
        (apply make-node %)
        %)
     node-list))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute.vmfest" name="pallet.compute.vmfest"><h1 class="project-name">pallet.compute.vmfest</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A vmfest provider.</p>

<p>   An example service configuration in ~/.pallet/config.clj</p>

<pre><code>   :vb {:provider "virtualbox"
        :images {:centos-5-3 {:description "CentOS 5.3 32bit"
                              :uuid "4697bdf7-7acf-4a20-8c28-e20b6bb58e25"
                              :os-family :centos
                              :os-version "5.3"
                              :os-type-id "RedHat"}
                 :ubuntu-10-04 {:description "Ubuntu 10.04 32bit"
                                :uuid "8a31e3aa-0d46-41a5-936d-25130dcb16b7"
                                :os-family :ubuntu
                                :os-version "10.04"
                                :os-type-id "Ubuntu"
                                :username
                                :password}}
        :model-path "/Volumes/My Book/vms/disks"
        :node-path "/Volumes/My Book/vms/nodes"}
</code></pre>

<p>   The uuid's can be found using vboxmanage
       vboxmanage list hdds</p>

<p>   The images are disks that are immutable.  The virtualbox extensions need
   to be installed on the image.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute.vmfest
  "A vmfest provider.
   An example service configuration in ~/.pallet/config.clj
       :vb {:provider \"virtualbox\"
            :images {:centos-5-3 {:description \"CentOS 5.3 32bit\"
                                  :uuid \"4697bdf7-7acf-4a20-8c28-e20b6bb58e25\"
                                  :os-family :centos
                                  :os-version \"5.3\"
                                  :os-type-id \"RedHat\"}
                     :ubuntu-10-04 {:description \"Ubuntu 10.04 32bit\"
                                    :uuid \"8a31e3aa-0d46-41a5-936d-25130dcb16b7\"
                                    :os-family :ubuntu
                                    :os-version \"10.04\"
                                    :os-type-id \"Ubuntu\"
                                    :username
                                    :password}}
            :model-path \"/Volumes/My Book/vms/disks\"
            :node-path \"/Volumes/My Book/vms/nodes\"}
   The uuid's can be found using vboxmanage
       vboxmanage list hdds
   The images are disks that are immutable.  The virtualbox extensions need
   to be installed on the image."
  (:require
   [vmfest.virtualbox.virtualbox :as virtualbox]
   [vmfest.virtualbox.machine :as machine]
   [vmfest.virtualbox.model :as model]
   [vmfest.virtualbox.session :as session]
   [vmfest.manager :as manager]
   [pallet.compute :as compute]
   [pallet.compute.jvm :as jvm]
   [pallet.compute.implementation :as implementation]
   [pallet.core :as core]
   [pallet.script :as script]
   [pallet.execute :as execute]
   [pallet.resource :as resource]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers []
  ["virtualbox"])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def os-family-name
  {:ubuntu "Ubuntu"
   :centos "RedHat"
   ;:rhel "RedHat"
   :rhel "RedHat_64"})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def os-family-from-name
  (zipmap (vals os-family-name) (keys os-family-name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(extend-type vmfest.virtualbox.model.Machine
  pallet.compute/Node
  (ssh-port [node] 22)
  (primary-ip
   [node]
   (condition/handler-case
    :type
    (manager/get-ip node)
    (handle :vbox-runtime
      (manager/get-extra-data node "/pallet/ip"))))
  (private-ip [node] nil)
  (is-64bit?
   [node]
   (let [os-type-id (:os-type-id (manager/as-map node))]
     (re-find #"64 bit" os-type-id)))
  (tag
   [node]
   (manager/get-extra-data node "/pallet/tag"))
  (hostname
   [node]
   (:name (manager/as-map node)))
  (os-family
   [node]
   (let [os-name (:os-type-id (manager/as-map node))]
     (or
      (keyword (manager/get-extra-data node "/pallet/os-family"))
      (os-family-from-name os-name os-name)
      :centos) ;; hack!
     ))
  (os-version
   [node]
   (or
      (manager/get-extra-data node "/pallet/os-version")
      "5.3"))
  (running?
   [node]
   (and
    (session/with-no-session node [vb-m] (.getAccessible vb-m))
    (= :running (manager/state node))))
  (terminated? [node] false)
  (id [node] (:id node)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nil-if-blank [x]
  (if (string/blank? x) nil x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- current-time-millis []
  (System/currentTimeMillis))</pre></tr><tr><td class="docs"><p>Wait for the machines IP to become available.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-ip
  ([machine] (wait-for-ip machine 300000))
  ([machine timeout]
     (let [timeout (+ (current-time-millis) timeout)]
       (loop []
         (try
           (let [ip (try (manager/get-ip machine)
                         (catch org.virtualbox_4_0.VBoxException e
                           (logging/warn
                            (format
                             "wait-for-ip: Machine %s not started yet..."
                             machine)))
                         (catch clojure.contrib.condition.Condition e
                           (logging/warn
                            (format
                             "wait-for-ip: Machine %s is not accessible yet..."
                             machine))))]
             (if (and (string/blank? ip) (< (current-time-millis) timeout))
               (do
                 (Thread/sleep 2000)
                 (recur))
               ip)))))))</pre></tr><tr><td class="docs"><p>Generate a machine name</p>
</td><td class="codes" /><pre class="brush: clojure">(defn machine-name
  [tag n]
  (format "%s-%s" tag n))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defprotocol VirtualBoxService
  (os-families [compute] "Return supported os-families")
  (medium-formats [compute] "Return supported medium-formats"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-data [m]
  (let [node-map (manager/as-map m)
        attributes (select-keys node-map [:name :description :session-state])
        open? (= :open (:session-state node-map))
        ip (when open? (manager/get-ip m))
        tag (when open? (manager/get-extra-data m "/pallet/tag"))]
    (into attributes {:ip ip :tag tag}) ))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-infos [compute-service]
  (let [nodes (manager/machines compute-service)]
    (map node-data nodes)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *vm-session-type* "headless")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn create-node
  [compute node-path node-type machine-name images image-id tag-name
   init-script user]
  {:pre [image-id]}
  (logging/trace (format "Creating node from image-id: %s" image-id))
  (let [machine (manager/instance
                 compute machine-name image-id :micro node-path)
        image (image-id images)]
    (manager/set-extra-data machine "/pallet/tag" tag-name)
    (manager/set-extra-data machine "/pallet/os-family" (name (:os-family image)))
    (manager/set-extra-data machine "/pallet/os-version" (:os-version image))
    ;; (manager/add-startup-command machine 1 init-script )
    (manager/start machine :session-type *vm-session-type*)
    (logging/trace "Wait to allow boot")
    (Thread/sleep 15000)                ; wait minimal time for vm to boot
    (logging/trace "Waiting for ip")
    (when (string/blank? (wait-for-ip machine))
      (condition/raise
       :type :no-ip-available
       :message "Could not determine IP address of new node"))
    (Thread/sleep 4000)
    (logging/trace (format "Bootstrapping %s" (manager/get-ip machine)))
    (script/with-template
      (resource/script-template {:node-type {:image image}})
      (execute/remote-sudo
       (manager/get-ip machine)
       init-script
       (if (:username image)
         (pallet.utils/make-user
          (:username image)
          :password (:password image)
          :no-sudo (:no-sudo image))
         user)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- equality-match
  [image-properties kw arg]
  (= (image-properties kw) arg))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- regexp-match
  [image-properties kw arg]
  (re-matches (re-pattern arg) (image-properties kw)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def template-matchers
  {:os-version-matches (fn [image-properties kw arg]
                         (regexp-match image-properties :os-version arg))})</pre></tr><tr><td class="docs"><p>Use the template to select an image from the image map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn image-from-template
  [images template]
  (if-let [image-id (:image-id template)]
    (image-id images)
    (->
     (filter
      (fn image-matches? [[image-name image-properties]]
        (every?
         #(((first %) template-matchers equality-match)
           image-properties (first %) (second %))
         (dissoc template :image-id :inbound-ports)))
      images)
     ffirst)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype VmfestService
    [server images locations]
  pallet.compute/ComputeService
  (nodes
   [compute-service]
   (manager/machines server))

  (ensure-os-family
   [compute-service request]
   request)

  ;; Not implemented
  ;; (build-node-template)

  (run-nodes
   [compute-service node-type node-count request init-script]
   (try
     (let [image-id (or (image-from-template images (-> node-type :image))
                        (throw (RuntimeException.
                                (format "No matching image for %s"
                                        (pr-str (-> node-type :image))))))
           tag-name (name (:tag node-type))
           machines (filter
                     #(session/with-no-session % [vb-m] (.getAccessible vb-m))
                     (manager/machines server))
           current-machines-in-tag (filter
                                    #(= tag-name
                                        (manager/get-extra-data
                                         % "/pallet/tag"))
                                    machines)
           current-machine-names (into #{}
                                       (map
                                        #(:name (manager/as-map %))
                                        current-machines-in-tag))
           target-indices (range (+ node-count
                                    (count current-machines-in-tag)))
           target-machine-names (into #{}
                                      (map
                                       #(machine-name tag-name %)
                                       target-indices))
           target-machines-already-existing (clojure.set/intersection
                                             current-machine-names
                                             target-machine-names)
           target-machines-to-create (clojure.set/difference
                                      target-machine-names
                                      target-machines-already-existing)]
       (logging/debug (str "current-machine-names " current-machine-names))
       (logging/debug (str "target-machine-names " target-machine-names))
       (logging/debug (str "target-machines-already-existing "
                           target-machines-already-existing))
       (logging/debug (str "target-machines-to-create"
                           target-machines-to-create))
       (binding [manager/*images* images]
         (doseq [name target-machines-to-create]
           (create-node
            server (:node-path locations) node-type name
            images image-id tag-name
            init-script
            (:user request)))))))

  (reboot
   [compute nodes]
   (compute/shutdown server nodes nil)
   (compute/boot-if-down server nodes))

  (boot-if-down
   [compute nodes]
   (doseq [node nodes]
     (manager/start node)))

  (shutdown-node
   [compute node _]
   ;; todo: wait for completion
   (logging/info (format "Shutting down %s" (pr-str node)))
   (manager/power-down node)
   (if-let [state (manager/wait-for-machine-state node [:powered-off] 300000)]
     (logging/info (format "Machine state is %s" state))
     (logging/warn "Failed to wait for power down completion"))
   (manager/wait-for-lockable-session-state node 2000))

  (shutdown
   [compute nodes user]
   (doseq [node nodes]
     (compute/shutdown-node server node user)))

  (destroy-nodes-with-tag
    [compute tag-name]
    (doseq [machine
            (filter
             #(and
               (compute/running? %)
               (= tag-name (manager/get-extra-data % "/pallet/tag")))
             (manager/machines server))]
      (compute/destroy-node compute machine)))

  (destroy-node
   [compute node]
   {:pre [node]}
   (compute/shutdown-node compute node nil)
   (manager/destroy node))

  (close [compute]))</pre></tr><tr><td class="docs"><p>Compute service</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod implementation/service :virtualbox
  [_ {:keys [url identity credential images node-path model-path locations]
      :or {url "http://localhost:18083/"
           identity "test"
           credential "test"}
      :as options}]
  (let [locations (or locations
                      {:local (select-keys options [:node-path :model-path])})]
    (VmfestService.
     (vmfest.virtualbox.model.Server. url identity credential)
     images
     (val (first locations)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod clojure.core/print-method vmfest.virtualbox.model.Machine
  [node writer]
  (.write
   writer
   (format
    "%14s\t %14s\t public: %s"
    (compute/hostname node)
    (compute/tag node)
    (compute/primary-ip node))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.compute" name="pallet.compute"><h1 class="project-name">pallet.compute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Abstraction of the compute interface</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.compute
  (:require
   [pallet.compute.implementation :as implementation]
   [pallet.configure :as configure]
   [pallet.utils :as utils]
   [pallet.execute :as execute]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>A list of supported provider names.  Each name is suitable to be passed
   to compute-service.</p>

<p>Meta</p>
</td><td class="codes" /><pre class="brush: clojure">(defn supported-providers
  []
  (implementation/supported-providers))</pre></tr><tr><td class="docs"><p>Instantiate a compute service. The provider name should be a recognised
   jclouds provider, or "node-list". The other arguments are keyword value
   pairs.
     :identity     username or key
     :credential   password or secret
     :extensions   extension modules for jclouds
     :node-list    a list of nodes for the "node-list" provider.</p>

<p>Compute Service instantiation</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service
  "Instantiate a compute service. The provider name should be a recognised
   jclouds provider, or \"node-list\". The other arguments are keyword value
   pairs.
     :identity     username or key
     :credential   password or secret
     :extensions   extension modules for jclouds
     :node-list    a list of nodes for the \"node-list\" provider."
  [provider-name
   & {:keys [identity credential extensions node-list endpoint] :as options}]
  (implementation/load-providers)
  (implementation/service provider-name options))</pre></tr><tr><td class="docs"><p>Create a compute service from a credentials map.
   Uses the :provider, :identity, :credential, :extensions and :node-list keys.
   The :extensions and :node-list keys will be read with read-string if they
   are strings.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-map
  [credentials]
  (let [options {:identity (:identity credentials)
                 :credential (:credential credentials)
                 :extensions (when-let [extensions (:extensions credentials)]
                               (if (string? extensions)
                                 (map
                                  read-string
                                  (string/split extensions #" "))
                                 extensions))
                 :node-list (when-let [node-list (:node-list credentials)]
                              (if (string? node-list)
                                (read-string node-list)
                                node-list))
                 :endpoint (:endpoint credentials)}]
    (when-let [provider (:provider credentials)]
      (apply
       compute-service
       provider
       (apply concat (filter second options))))))</pre></tr><tr><td class="docs"><p>Create a compute service from maven property settings.
   In Maven's settings.xml you can define a profile, that contains
   pallet.compute.provider, pallet.compute.identity and
   pallet.compute.credential values.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-settings
  [& profiles]
  (try
    (require 'pallet.maven) ; allow running without maven jars
    (when-let [f (ns-resolve 'pallet.maven 'credentials)]
      (compute-service-from-map (f profiles)))
    (catch ClassNotFoundException _)
    (catch clojure.lang.Compiler$CompilerException _)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compute-service-from-var
  [ns sym]
  (utils/find-var-with-require ns sym))</pre></tr><tr><td class="docs"><p>Checks to see if pallet.config/service is a var, and if so returns its
  value.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config-var
  []
  (compute-service-from-var 'pallet.config 'service))</pre></tr><tr><td class="docs"><p>If the pallet.config.service property is defined, and refers to a var, then
   return its value.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-property
  []
  (when-let [property (System/getProperty "pallet.config.service")]
    (when-let [sym-names (and (re-find #"/" property)
                              (string/split property #"/"))]
      (compute-service-from-var
       (symbol (first sym-names)) (symbol (second sym-names))))))</pre></tr><tr><td class="docs"><p>Compute service from a configuration map and a list of active profiles
   (provider keys).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config
  [config profiles]
  (let [{:keys [provider identity credential]
         :as options}
        (configure/compute-service-properties config profiles)]
    (when provider
      (apply compute-service
       provider :identity identity :credential credential
       (apply concat (dissoc options :provider :identity :credential))))))</pre></tr><tr><td class="docs"><p>Compute service from ~/.pallet/config.clj. Profiles is a sequence of provider
   keys to use from the :providers map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-from-config-file
  [& profiles]
  (compute-service-from-config
   (configure/pallet-config)
   profiles))</pre></tr><tr><td class="docs"><p>Nodes</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol Node
  (ssh-port [node] "Extract the port from the node's userMetadata")
  (primary-ip [node] "Returns the first public IP for the node.")
  (private-ip [node] "Returns the first private IP for the node.")
  (is-64bit? [node] "64 Bit OS predicate")
  (tag [node] "Returns the tag for the node.")
  (hostname [node] "TODO make this work on ec2")
  (os-family [node] "Return a node's os-family, or nil if not available.")
  (os-version [node] "Return a node's os-version, or nil if not available.")
  (running? [node])
  (terminated? [node])
  (id [node]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-has-tag? [tag-name node]
  (= (clojure.core/name tag-name) (tag node)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-address
  [node]
  (if (string? node)
    node
    (primary-ip node)))</pre></tr><tr><td class="docs"><p>Actions</p>
</td><td class="codes" /><pre class="brush: clojure">(defprotocol ComputeService
  (nodes [compute] "List nodes")
  (run-nodes [compute node-type node-count request init-script])
  (reboot [compute nodes] "Reboot the specified nodes")
  (boot-if-down
   [compute nodes]
   "Boot the specified nodes, if they are not running.")
  (shutdown-node [compute node user] "Shutdown a node.")
  (shutdown [compute nodes user] "Shutdown specified nodes")
  (ensure-os-family
   [compute request]
   "Called on startup of a new node to ensure request has an os-family attached
   to it.")
  (destroy-nodes-with-tag [compute tag-name])
  (destroy-node [compute node])
  (close [compute]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (conj (get %1 (keyword (tag %2)) []) %2)) {} nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn node-counts-by-tag [nodes]
  (reduce #(assoc %1
             (keyword (tag %2))
             (inc (get %1 (keyword (tag %2)) 0))) {} nodes))</pre></tr><tr><td class="docs"><p>Package manager</p>

<p>target mapping</p>
</td><td class="codes" /><pre class="brush: clojure">(defn packager
  [target]
  (or
   (:packager target)
   (let [os-family (:os-family target)]
     (cond
      (#{:ubuntu :debian :jeos :fedora} os-family) :aptitude
      (#{:centos :rhel :amzn-linux} os-family) :yum
      (#{:arch} os-family) :pacman
      (#{:suse} os-family) :zypper
      (#{:gentoo} os-family) :portage
      (#{:darwin :os-x} os-family) :brew
      :else (condition/raise
             :type :unknown-packager
             :message (format
                       "Unknown packager for %s - :image %s"
                       os-family target))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.configure" name="pallet.configure"><h1 class="project-name">pallet.configure</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Pallet configuration</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.configure
  (:require
   [clojure.java.io :as java-io]
   [clojure.walk :as walk]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} config nil)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- unquote-vals [args]
  (walk/walk
   (fn [item]
     (cond (and (seq? item) (= `unquote (first item))) (second item)
           ;; needed if we want fn literals to be usable by eval-in-project
           (and (seq? item) (= 'fn (first item))) (list 'quote item)
           (symbol? item) (list 'quote item)
           :else (unquote-vals item)))
   identity
   args))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defpallet
  [& {:keys [provider identity credential providers admin-user]
      :as config-options}]
  `(let [m# (zipmap
             ~(cons 'list (keys config-options))
             ~(cons 'list (unquote-vals (vals config-options))))]
    (alter-var-root
     #'config
     (fn [_#] m#))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- read-config
  [file]
  (try
    (use '[pallet.configure :only [defpallet]])
    (load-file file)
    config
    (catch java.io.FileNotFoundException _)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- home-dir
  "Returns full path to Pallet home dir ($PALLET_HOME or $HOME/.pallet)"
  []
  (.getAbsolutePath
   (doto (if-let [pallet-home (System/getenv "PALLET_HOME")]
           (java.io.File. pallet-home)
           (java.io.File. (System/getProperty "user.home") ".pallet"))
     .mkdirs)))</pre></tr><tr><td class="docs"><p>Read pallet configuration file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pallet-config
  []
  (read-config (.getAbsolutePath (java-io/file (home-dir) "config.clj"))))</pre></tr><tr><td class="docs"><p>Helper to read compute service properties</p>
</td><td class="codes" /><pre class="brush: clojure">(defn compute-service-properties
  [config profiles]
  (when config
    (when (:providers config)
      (logging/warn
       "DEPRECATED: use of :providers key in ~/.pallet/config.clj
      is deprecated. Please change to use :services."))
    (let [service (first profiles)
          default-service (map config [:provider :identity :credential])
          services (:services config (:providers config))]
      (cond
       (every? identity default-service) (select-keys
                                          config
                                          [:provider :identity :credential
                                           :blobstore :endpoint])
       (map? services) (or
                        (and service (or
                                      (services (keyword service))
                                      (services service)))
                        (and (not service) ; use default if no profile
                                        ; requested
                             (first services)
                             (-> services first val)))
       :else nil))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.core" name="pallet.core"><h1 class="project-name">pallet.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Core functionality is provided in <code>lift</code> and <code>converge</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns ^{:author "Hugo Duncan"}
  pallet.core
  (:require
   [pallet.blobstore :as blobstore]
   [pallet.compute :as compute]
   [pallet.execute :as execute]
   [pallet.utils :as utils]
   [pallet.script :as script]
   [pallet.target :as target]
   [pallet.parameter :as parameter]
   [pallet.resource :as resource]
   [clojure.contrib.condition :as condition]
   [clojure.string :as string]
   [clojure.contrib.logging :as logging]
   [clojure.contrib.map-utils :as map-utils]))</pre></tr><tr><td class="docs"><p>Returns the pallet version.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn version
  []
  (or
   (System/getProperty "pallet.version")
   (if-let [version (utils/slurp-resource "pallet-version")]
     (string/trim version))))</pre></tr><tr><td class="docs"><p>Set the agent string for http requests.</p>
</td><td class="codes" /><pre class="brush: clojure">(. System setProperty "http.agent"
   (str "Pallet " (version)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-admin-user
  "Specify the admin user for running remote commands.  The user is specified
   either as pallet.utils.User record (see the pallet.utils/make-user
   convenience fn) or as an argument list that will be passed to make-user."
  {:arglists
   '([user & body]
     [[username & {:keys [public-key-path private-key-path passphrase
                          password sudo-password no-sudo] :as options}]
      & body])}
  [user & exprs]
  `(let [user# ~user]
     (binding [utils/*admin-user* (if (utils/user? user#)
                                    user#
                                    (apply utils/make-user user#))]
       ~@exprs)))</pre></tr><tr><td class="docs"><p>Set the root binding for the admin user.
  The user arg is a map as returned by make-user, or a username.  When passing a
  username the options can be specified as in <code>pallet.utils/make-user</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user
  {:arglists
   '([user]
     [username & {:keys [public-key-path private-key-path passphrase
                         password sudo-password no-sudo] :as options}])}
  [user & options]
  (alter-var-root
   #'utils/*admin-user*
   #(identity %2)
   (if (string? user)
     (apply utils/make-user user options)
     user)))</pre></tr><tr><td class="docs"><p>Create a node definition.  See defnode.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-node
  [name image & {:as phase-map}]
  {:pre [(or (nil? image) (map? image))]}
  {:tag (keyword name)
   :image image
   :phases phase-map})</pre></tr><tr><td class="docs"><p>Modified version, of that found in contrib, to handle the image map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn name-with-attributes
  [name macro-args]
  (let [[docstring macro-args] (if (string? (first macro-args))
                                 [(first macro-args) (next macro-args)]
                                 [nil macro-args])
        [attr macro-args] (if (and (map? (first macro-args))
                                   (map? (first (next macro-args))))
                            [(first macro-args) (next macro-args)]
                            [{} macro-args])
        attr (if docstring
               (assoc attr :doc docstring)
               attr)
        attr (if (meta name)
               (conj (meta name) attr)
               attr)]
    [(with-meta name attr) macro-args]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defnode
  "Define a node type.  The name is used for the node tag.

   image defines the image selector template.  This is a vector of keyword or
          keyword value pairs that are used to filter the image list to select
          an image.
   Options are used to define phases. Standard phases are:
     :bootstrap    run on first boot
     :configure    defines the configuration of the node."
  {:arglists ['(tag doc-str? attr-map? image & phasekw-phasefn-pairs)]}
  [tag & options]
  (let [[tag options] (name-with-attributes tag options)]
    `(def ~tag (make-node '~(name tag) ~@options))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-os-family
  "Add the os family to the node-type if available from node."
  [request]
  (let [node (:target-node request)
        family (and node (compute/os-family node))
        version (and node (compute/os-version node))]
    (->
     request
     (update-in
      [:node-type :image :os-family]
      (fn ensure-os-family [f]
        (or family f)))
     (update-in
      [:node-type :image :os-version]
      (fn ensure-os-family-version [f]
        (or version f))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-target-id
  "Add the target-id to the request"
  [request]
  (update-in
   request [:target-id]
   (fn ensure-target-id [id]
     (or
      (when-let [node (:target-node request)] (keyword (compute/id node)))
      id))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-target-packager
  "Add the target packager to the request"
  [request]
  (update-in
   request [:target-packager]
   (fn ensure-target-packager [p]
     (or p (compute/packager (get-in request [:node-type :image]))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-target-keys
  "Add target keys on the way down"
  [handler]
  (fn [request]
    (handler
     (-> request
         add-os-family
         add-target-packager
         add-target-id))))</pre></tr><tr><td class="docs"><p>Middleware that is useful in debugging.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn show-target-keys
  [handler]
  (fn [request]
    (logging/info
     (format
      "TARGET KEYS :phase %s :target-id %s :tag %s :target-packager %s"
      (:phase request)
      (:target-id request)
      (:tag (:node-type request))
      (:target-packager request)))
    (handler request)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- resource-invocations [request]
  {:pre [(:phase request)]}
  (if-let [f (some
              (:phase request)
              [(:phases (:node-type request)) (:phases request)])]
    (let [request ((utils/pipe add-target-keys identity) request)]
      (script/with-template (resource/script-template request)
        (f request)))
    request))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- produce-init-script
  [request]
  {:pre [(get-in request [:node-type :image :os-family])
         (get-in request [:target-packager])]}
  (let [cmds
        (resource/produce-phase
         (resource-invocations
          (assoc request :phase :bootstrap :target-id :bootstrap-id)))]
    (if-not (and (every? #(= :remote (:location %)) cmds) (>= 1 (count cmds)))
      (condition/raise
       :type :booststrap-contains-local-resources
       :message (format
                 "Bootstrap can not contain local resources %s"
                 (pr-str cmds))))
    (if-let [f (:f (first cmds))]
      (script/with-template (resource/script-template request)
        (logging/info
         (format
          "Generating init script - :os-family %s, :packager %s, *template* %s"
          (-> request :node-type :image :os-family)
          (-> request :target-packager)
          (vec script/*template*)))
        (:cmds (f request)))
      "")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- create-nodes
  "Create count nodes based on the template for tag. The boostrap argument
expects a map with :authorize-public-key and :bootstrap-script keys.  The
bootstrap-script value is expected tobe a function that produces a
script that is run with root privileges immediatly after first boot."
  [node-type count request]
  {:pre [(map? node-type)]}
  (logging/info
   (str "Starting " count " nodes for " (node-type :tag)
        " os-family " (-> node-type :image :os-family)))
  (let [request (compute/ensure-os-family
                 (:compute request)
                 (assoc request :node-type node-type))
        request (add-target-packager request)
        init-script (produce-init-script request)]
    (logging/trace
     (format "Bootstrap script:\n%s" init-script))
    (compute/run-nodes
     (:compute request)
     node-type
     count
     request
     init-script)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- destroy-nodes-with-count
  "Destroys the specified number of nodes with the given tag.  Nodes are
   selected at random."
  [nodes tag destroy-count compute]
  (logging/info (str "destroying " destroy-count " nodes with tag " tag))
  (let [tag-nodes (filter (partial compute/node-has-tag? tag) nodes)]
    (if (= destroy-count (count tag-nodes))
      (compute/destroy-nodes-with-tag compute (name tag))
      (doseq [node (take destroy-count tag-nodes)]
        (compute/destroy-node compute node)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-count-difference
  "Find the difference between the required and actual node counts by tag."
  [node-map nodes]
  (let [node-counts (compute/node-counts-by-tag nodes)]
    (merge-with
     - node-map
     (into {} (map #(vector (first %) (get node-counts ((first %) :tag) 0))
                   node-map)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- adjust-node-counts
  "Start or stop the specified number of nodes."
  [delta-map nodes request]
  (logging/trace (str "adjust-node-counts" delta-map))
  (logging/info (str "destroying excess nodes"))
  (doseq [node-count (filter #(neg? (second %)) delta-map)]
    (destroy-nodes-with-count
      nodes ((first node-count) :tag) (- (second node-count))
      (:compute request)))
  (logging/info (str "adjust-node-counts starting new nodes"))
  (mapcat #(create-nodes (first %) (second %) request)
          (filter #(pos? (second %)) delta-map)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- converge-node-counts
  "Converge the nodes counts, given a compute facility and a reference number of
   instances."
  [node-map nodes request]
  (logging/info "converging nodes")
  (logging/trace (str "  " node-map))
  ;;(compute/boot-if-down (:compute request) nodes) ; this needs improving
                                        ; should only reboot if required
  (let [nodes (filter compute/running? nodes)]
    (adjust-node-counts
     (node-count-difference node-map nodes)
     nodes
     request)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn execute-with-ssh
  [{:keys [target-node] :as request}]
  (execute/ssh-cmds
   (assoc request
     :address (compute/node-address target-node)
     :ssh-port (compute/ssh-port target-node))))</pre></tr><tr><td class="docs"><p>Middleware to execute on localhost with shell</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute-with-local-sh
  [handler]
  (fn [{:as request}]
    (execute/local-sh-cmds request)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn parameter-keys [node node-type]
  [:default
   (compute/packager (node-type :image))
   (target/os-family (node-type :image))])</pre></tr><tr><td class="docs"><p>Middleware to set parameters based on a specified parameter map</p>
</td><td class="codes" /><pre class="brush: clojure">(defn with-target-parameters
  [handler parameters]
  (fn [request]
    (handler
     (assoc
         request :parameters
         (parameter/from-map
          parameters
          (parameter-keys (:target-node request) (:node-type request)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-commands
  [handler]
  (fn [request]
    {:pre [handler
           (-> request :node-type :image :os-family)
           (-> request :target-packager)]}
    (if-let [commands (script/with-template (resource/script-template request)
                        (resource/produce-phase request))]
      (handler (assoc request :commands commands))
      [nil request])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-phase-to-node
  "Apply a phase to a node request"
  [request]
  {:pre [(:target-node request)]}
  (let [middleware (:middleware request)]
    ((utils/pipe
      add-target-keys
      build-commands
      middleware
      execute-with-ssh)
     request)))</pre></tr><tr><td class="docs"><p>Middleware to report on the request, without executing</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wrap-no-exec
  [_]
  (fn [request]
    (logging/info
     (format
      "Commands on node %s as user %s"
      (pr-str (:node request))
      (pr-str (:user request))))
    (letfn [(execute
             [cmd]
             (logging/info (format "Commands %s" cmd))
             cmd)]
      (resource/execute-commands request {:script/bash execute
                                          :transfer/to-local (fn [& _])
                                          :transfer/from-local (fn [& _])}))))</pre></tr><tr><td class="docs"><p>Middleware to execute only local functions</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wrap-local-exec
  [_]
  (fn [request]
    (letfn [(execute [cmd] nil)]
      (resource/execute-commands request {:script/bash execute
                                          :transfer/to-local (fn [& _])
                                          :transfer/from-local (fn [& _])}))))</pre></tr><tr><td class="docs"><p>Middleware to user the request :user credentials for SSH authentication.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wrap-with-user-credentials
  [handler]
  (fn [request]
    (logging/info
     (format
      "Using identity at %s"
      (:private-key-path (:user request))))
    (execute/possibly-add-identity
     (execute/default-agent)
     (:private-key-path (:user request))
     (:passphrase (:user request)))
    (handler request)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *middleware* wrap-with-user-credentials)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-middleware
  "Wrap node execution in the given middleware. A middleware is a function of
   one argument (a handler function, that is the next middleware to call) and
   returns a dunction of one argument (the request map).  Middleware can be
   composed with the pipe macro."
  [f & body]
  `(binding [*middleware* ~f]
     ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- reduce-phase-results
  "Combine the execution results."
  [request results]
  (reduce
   (fn apply-phase-accumulate [request [result req :as arg]]
     (let [param-keys [:parameters :host (:target-id req)]]
       (->
        request
        (assoc-in [:results (:target-id req) (:phase req)] result)
        (update-in
         param-keys
         (fn [p]
           (map-utils/deep-merge-with
            (fn [x y] (or y x)) p (get-in req param-keys)))))))
   request
   results))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- reduce-results
  "Reduce across all phase results"
  [request results]
  (reduce
   (fn lift-nodes-reduce-result [request req]
     (let [req (reduce-phase-results request req)]
       (->
        request
        (update-in
         [:results]
         #(map-utils/deep-merge-with
           (fn [x y] (or y x)) (or % {}) (:results req)))
        (update-in
         [:parameters]
         #(map-utils/deep-merge-with
           (fn [x y] (or y x)) % (:parameters req))))))
   request
   results))</pre></tr><tr><td class="docs"><p>Apply a phase to a sequence of nodes</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sequential-apply-phase
  [request nodes]
  (logging/info
   (format
    "apply-phase %s for %s with %d nodes"
    (:phase request) (:tag (:node-type request)) (count nodes)))
  (for [node nodes]
    (apply-phase-to-node
     (assoc request :target-node node))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- nodes-in-map
  "Return nodes with tags corresponding to the keys in node-map"
  [node-map nodes]
  (let [tags (->> node-map keys (map :tag) (map name) set)]
    (->> nodes (filter compute/running?) (filter #(-> % compute/tag tags)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- filter-nodes-with-tag
  "Return nodes with the given tag"
  [nodes with-tag]
  (filter #(= (name with-tag) (compute/tag %)) nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-prefix-to-node-type
  [prefix node-type]
  (update-in node-type [:tag]
             (fn [tag] (keyword (str prefix (name tag))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-prefix-to-node-map [prefix node-map]
  (zipmap
   (map (partial add-prefix-to-node-type prefix) (keys node-map))
   (vals node-map)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- ensure-configure-phase [phases]
  (if (some #{:configure} phases)
    phases
    (concat [:configure] phases)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-in-types?
  "Predicate for matching a node belonging to a set of node types"
  [node-types node]
  (some #(= (compute/tag node) (name (% :tag))) node-types))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- nodes-for-type
  "Return the nodes that have a tag that matches one of the node types"
  [nodes node-type]
  (let [tag-string (name (node-type :tag))]
    (filter #(compute/node-has-tag? tag-string %) nodes)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- node-type?
  "Predicate for testing if argument is node-type."
  [x]
  (and (map? x) (x :tag) (x :image) true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- nodes-in-set
  "Build a map of nodes for the given node-set. A node set can be a node type, a
   sequence of node types, a node node-typ vector, or a sequence of nodes.
     e.g [node-type1 node-type2 {node-type #{node1 node2}}]

  The return value is a map of node-type -> node sequence."
  [node-set prefix nodes]
  (letfn [(ensure-set [x] (if (set? x) x #{x}))
          (ensure-set-values
           [m]
           (zipmap (keys m) (map ensure-set (vals m))))]
    (cond
     (and (map? node-set) (not (node-type? node-set)))
     (ensure-set-values (add-prefix-to-node-map prefix node-set))
     (node-type? node-set)
     (let [node-type (add-prefix-to-node-type prefix node-set)]
       {node-type (set (nodes-for-type nodes node-type))})
     :else (reduce
            #(merge-with concat %1 %2) {}
            (map #(nodes-in-set % prefix nodes) node-set)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- identify-anonymous-phases
  [request phases]
  (reduce #(if (keyword? %2)
             [(first %1)
              (conj (second %1) %2)]
             (let [phase (keyword (name (gensym "phase")))]
               [(assoc-in (first %1) [:phases phase] %2)
                (conj (second %1) phase)])) [request []] phases))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- invoke-for-nodes
  "Build an invocation map for specified nodes."
  [request nodes]
  (reduce
   #(resource-invocations
     (assoc %1 :target-node %2 :target-id (keyword (compute/id %2))))
   request nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- invoke-for-node-type
  "Build an invocation map for specified node-type map."
  [request node-map]
  (reduce
   #(invoke-for-nodes (assoc %1 :node-type (first %2)) (second %2))
   request node-map))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- invoke-phases
  "Build an invocation map for specified phases and nodes.
   This allows configuration to be accumulated in the request parameters."
  [request phases node-map]
  (reduce #(invoke-for-node-type (assoc %1 :phase %2) node-map) request phases))</pre></tr><tr><td class="docs"><p>Sequential apply the phases.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sequential-lift
  [request phases target-node-map]
  (for [phase (resource/phase-list phases)
        [node-type tag-nodes] target-node-map]
    (sequential-apply-phase
     (assoc request :phase phase :node-type node-type)
     tag-nodes)))</pre></tr><tr><td class="docs"><p>Lift nodes in target-node-map for the specified phases.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn lift-nodes
  [all-nodes target-node-map all-node-map phases request]
  (logging/trace (format "lift-nodes phases %s" (vec phases)))
  (let [target-nodes (filter compute/running?
                             (apply concat (vals target-node-map)))
        all-nodes (or all-nodes target-nodes) ; Target node map may contain
                                        ; unmanged nodes
        [request phases] (identify-anonymous-phases request phases)
        request (assoc request :all-nodes all-nodes :target-nodes target-nodes)]
    (reduce-results
     request
     (->
      request
      (invoke-phases (ensure-configure-phase phases) all-node-map)
      (sequential-lift phases target-node-map)))))</pre></tr><tr><td class="docs"><p>Flag to control output of warnings about undefined phases in calls to lift
     and converge.</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc
    }
  *warn-on-undefined-phase* true)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- warn-on-undefined-phase
  [all-node-map phases]
  (when *warn-on-undefined-phase*
    (when-let [undefined (seq (filter
                               (fn [phase]
                                 (if (keyword? phase)
                                   (not (some
                                         (fn [[{:keys [phases]} _]]
                                           (phase phases))
                                         all-node-map))
                                   false))
                               phases))]
      (logging/warn
       (format
        "Undefined phases: %s"
        (string/join ", " (map name undefined)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn lift*
  [node-set all-node-set phases request]
  (logging/trace (format "lift* phases %s" (vec phases)))
  (let [nodes (or
               (:all-nodes request)
               (when (:compute request)
                 (logging/info "retrieving nodes")
                 (filter
                  compute/running?
                  (compute/nodes (:compute request)))))
        target-node-map (nodes-in-set node-set (:prefix request) nodes)
        all-node-map (or (and all-node-set
                              (nodes-in-set all-node-set nil nodes))
                         target-node-map)]
    (warn-on-undefined-phase all-node-map phases)
    (lift-nodes nodes target-node-map all-node-map phases request)))</pre></tr><tr><td class="docs"><p>Converge the node counts of each tag in node-map, executing each of the
   configuration phases on all the tags in node-map. Th phase-functions are
   also executed, but not applied, for any other nodes in all-node-set</p>
</td><td class="codes" /><pre class="brush: clojure">(defn converge*
  [node-map all-node-set phases request]
  {:pre [(map? node-map)]}
  (logging/trace (format "converge* %s %s" node-map phases))
  (logging/info "retrieving nodes")
  (let [node-map (add-prefix-to-node-map (:prefix request) node-map)
        nodes (compute/nodes (:compute request))]
    (converge-node-counts node-map nodes request)
    (let [nodes (filter
                 compute/running?
                 (compute/nodes (:compute request)))
          tag-groups (group-by #(keyword (compute/tag %)) nodes)
          target-node-map (into
                           {}
                           (map
                            #(vector % ((:tag %) tag-groups))
                            (keys node-map)))
          all-node-map (or (and all-node-set
                                (nodes-in-set all-node-set nil nodes))
                           target-node-map)
          phases (ensure-configure-phase phases)]
      (warn-on-undefined-phase all-node-map phases)
      (lift-nodes
       nodes target-node-map all-node-map phases request))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro or-fn [& args]
  `(fn or-args [current#]
     (or current# ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compute-from-options
  [current-value {:keys [compute compute-service]}]
  (or current-value
      compute
      (and compute-service
           (compute/compute-service
            (:provider compute-service)
            :identity (:identity compute-service)
            :credential (:credential compute-service)
            :extensions (:extensions compute-service)
            :node-list (:node-list compute-service)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- blobstore-from-options
  [current-value {:keys [blobstore blobstore-service]}]
  (or current-value
      blobstore
      (and blobstore-service
           (blobstore/service
            (:provider blobstore-service)
            :identity (:identity blobstore-service)
            :credential (:credential blobstore-service)
            :extensions (:extensions blobstore-service)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-request-map
  "Build a request map from the given options."
  [{:as options}]
  (->
   options
   (update-in [:compute] compute-from-options options)
   (update-in [:blobstore] blobstore-from-options options)
   (update-in [:user] (or-fn utils/*admin-user*))
   (update-in [:middleware] (or-fn *middleware*))))</pre></tr><tr><td class="docs"><p>A set of recognised argument keywords, used for input checking.</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc 
       :private true}
  argument-keywords
  #{:compute :blobstore :phase :user :prefix :middleware :all-node-set
    :all-nodes :parameters})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- check-arguments-map
  "Check an arguments map for errors."
  [{:as options}]
  (let [unknown (remove argument-keywords (keys options))]
    (when (and (:phases options) (not (:phase options)))
      (condition/raise
       :type :invalid-argument
       :message (str
                 "Please pass :phase and not :phases. :phase takes a single "
                 "phase or a sequence of phases.")
       :invalid-keys unknown))
    (when (seq unknown)
      (condition/raise
       :type :invalid-argument
       :message (format "Invalid argument keywords %s" (vec unknown))
       :invalid-keys unknown)))
  options)</pre></tr><tr><td class="docs"><p>Converge the existing compute resources with the counts specified in
   node-map.  The compute service may be supplied as an option, otherwise the
   bound compute-service is used.</p>

<p>   This applies the bootstrap phase to all new nodes, and the configure phase to
   all running nodes whose tag matches a key in the node map.  Additional phases
   can also be specified in the options, and will be applied to all matching
   nodes.  The :configure phase is always applied, as the first (post bootstrap)
   phase.  You can change the order in which the phases are applied by
   explicitly listing them.</p>

<p>   An optional tag prefix may be specified before the node-map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn converge
  [node-map & {:keys [compute blobstore user phase prefix middleware
                      all-nodes all-node-set]
               :as options}]
  (converge*
   node-map all-node-set
   (if (sequential? phase) phase (if phase [phase] nil))
   (->
    options
    (check-arguments-map)
    (dissoc :all-node-set :phase)
    (build-request-map))))</pre></tr><tr><td class="docs"><p>Lift the running nodes in the specified node-set by applying the specified
   phases.  The compute service may be supplied as an option, otherwise the
   bound compute-service is used.  The configure phase is applied by default
   unless other phases are specified.</p>

<p>   node-set can be a node type, a sequence of node types, or a map
   of node type to nodes. Examples:
              [node-type1 node-type2 {node-type #{node1 node2}}]
              node-type
              {node-type #{node1 node2}}</p>

<p>   options can also be keywords specifying the phases to apply, or an immediate
   phase specified with the phase macro, or a function that will be called with
   each matching node.</p>

<p>   Options:
    :compute         a jclouds compute service
    :compute-service a map of :provider, :identity, :credential, and
                     optionally :extensions for constructing a jclouds compute
                     service.
    :phase           a phase keyword, phase function, or sequence of these
    :middleware      the middleware to apply to the configuration pipeline
    :prefix          a prefix for the tag names
    :user            the admin-user on the nodes</p>
</td><td class="codes" /><pre class="brush: clojure">(defn lift
  [node-set & {:keys [compute phase prefix middleware all-node-set]
               :as options}]
  (lift*
   node-set all-node-set
   (if (sequential? phase) phase (if phase [phase] nil))
   (->
    options
    (check-arguments-map)
    (dissoc :all-node-set :phase)
    (build-request-map))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.debug" name="pallet.debug"><h1 class="project-name">pallet.debug</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Helpers for debugging.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.debug
  (:require
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>A crate function that will log the request map at the debug level, using
   the supplied format string.</p>

<pre><code>   (log-request request "The request is %s")
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn log-request
  "A crate function that will log the request map at the debug level, using
   the supplied format string.
       (log-request request \"The request is %s\")"
  ([request]
     (log-request request "%s"))
  ([request format-string]
     (logging/debug (format format-string (pr-str request)))
     request))</pre></tr><tr><td class="docs"><p>A crate function that will print the request map to <em>out</em>, using the supplied
   format string.</p>

<pre><code>   (print-request request "The request is %s")
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn print-request
  "A crate function that will print the request map to *out*, using the supplied
   format string.
       (print-request request \"The request is %s\")"
  ([request]
     (print-request request "%s"))
  ([request format-string]
     (println (format format-string (pr-str request)))
     request))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.enlive" name="pallet.enlive"><h1 class="project-name">pallet.enlive</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Wrappers for enlive to enable template specialisation and use xml.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.enlive
  (:use
   [pallet.template :only [find-template]]
   clojure.contrib.logging)
  (:require
   [net.cgrand.enlive-html :as enlive]))</pre></tr><tr><td class="docs"><p>(def memo-nodes
(memoize
(fn [source]
(if-let [source (find-template source)]
(map enlive/annotate
(enlive/select
(enlive/xml-resource source) [:body :> enlive/any-node]))))))</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>(defmacro deffragment
[name source args &amp; forms]
`(def ~name
(fn ~args
(if-let [nodes# (memo-nodes ~source)]
(enlive/flatmap
(enlive/transformation ~@forms) nodes#)))))</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn elt
 ([tag] (elt tag nil))
 ([tag attrs & content]
   {:tag tag
    :attrs attrs
    :content content}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-nodes
  [[nodes] & forms]
  `(enlive/flatmap (enlive/transformation ~@forms) ~nodes))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deffragment
  [name args & forms]
  `(defn ~name ~args
     (fn [nodes#] (enlive/at nodes# ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def memo-xml-resource
     (memoize
      (fn [source node-type]
        (if-let [source (find-template source node-type)]
          (enlive/xml-resource source)
          (error (str "No template found for " source " " (node-type :tag)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defsnippet
  "A snippet returns a collection of nodes."
  [name source node-type args & forms]
  `(defn ~name ~args
    (if-let [nodes# (memo-xml-resource ~source ~node-type)]
      (enlive/at nodes# ~@forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro xml-template
  "A template returns a seq of string:
   Overridden from enlive to defer evaluation of the source until runtime, and
   to enable specialisation on node-type"
  [source node-type args & forms]
  `(comp enlive/emit*
         (fn ~args
           (if-let [nodes# (memo-xml-resource ~source ~node-type)]
             (enlive/flatmap (enlive/transformation ~@forms) nodes#)))))</pre></tr><tr><td class="docs"><p>Emit a template, adding an XML Declaration.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn xml-emit
  [f & args]
  (str "<?xml version='1.0' encoding='utf-8'?>\n"
       (apply str (apply f args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-if [expr transform]
  `(if ~expr ~transform identity))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro transform-if-let [binding transform]
  `(if-let ~binding ~transform identity))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.execute" name="pallet.execute"><h1 class="project-name">pallet.execute</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Exectute commands.  At the moment the only available transport is ssh.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.execute
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]
   [pallet.utils :as utils]
   [pallet.resource :as resource]
   [pallet.resource.file :as file]
   [pallet.compute.jvm :as jvm]
   [clj-ssh.ssh :as ssh]
   [clojure.string :as string]
   [clojure.contrib.condition :as condition]
   [clojure.java.io :as io]
   [clojure.contrib.shell :as shell]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>Launch a system process, return a map containing the exit code, standard
  output and standard error of the process.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn system
  [cmd]
  (let [result (apply shell/sh :return-map true (.split cmd " "))]
    (when (pos? (result :exit))
      (logging/error (str "Command failed: " cmd "\n" (result :err))))
    (logging/info (result :out))
    result))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn bash [cmds]
  (utils/with-temp-file [file cmds]
    (system (str "/usr/bin/env bash " (.getPath file)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def prolog
  (str "#!/usr/bin/env bash\n"
       stevedore/hashlib))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- normalise-eol
  "Convert eol into platform specific value"
  [#^String s]
  (string/replace s #"[\r\n]+" (str \newline)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- strip-sudo-password
  "Elides the user's password or sudo-password from the given ssh output."
  [#^String s user]
  (string/replace
   s (format "\"%s\"" (or (:password user) (:sudo-password user))) "XXXXXXX"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript sudo-no-password [])
(stevedore/defimpl sudo-no-password :default []
  ("/usr/bin/sudo" -n))
(stevedore/defimpl sudo-no-password [#{:centos-5.3 :os-x :darwin :debian}] []
  ("/usr/bin/sudo"))</pre></tr><tr><td class="docs"><p>Construct a sudo command prefix for the specified user.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sudo-cmd-for
  [user]
  (if (or (= (:username user) "root") (:no-sudo user))
    ""
    (if-let [pw (:sudo-password user)]
      (str "echo \"" (or (:password user) pw) "\" | /usr/bin/sudo -S")
      (stevedore/script (sudo-no-password)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce default-agent-atom (atom nil))
(defn default-agent
  []
  (or @default-agent-atom
      (swap! default-agent-atom
             (fn [agent]
               (if agent
                 agent
                 (ssh/create-ssh-agent false))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn possibly-add-identity
  [agent private-key-path passphrase]
  (if passphrase
    (ssh/add-identity agent private-key-path passphrase)
    (ssh/add-identity-with-keychain agent private-key-path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- mktemp
  "Create a temporary remote file using the ssh `session` and the filename
  `prefix`"
  [session prefix]
  (let [result (ssh/ssh
                session
                (stevedore/script (println (make-temp-file prefix)))
                :return-map true)]
    (if (zero? (:exit result))
      (string/trim (result :out))
      (condition/raise
       :type :remote-execution-failure
       :message (format
                 "Failed to generate remote temporary file %s" (:err result))
       :exit (:exit result)
       :err (:err result)
       :out (:out result)))))</pre></tr><tr><td class="docs"><p>Execute remote command.
   Copies <code>command</code> to <code>tmpfile</code> on the remote node using the <code>sftp-channel</code>
   and executes the <code>tmpfile</code> as the specified <code>user</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn remote-sudo-cmd
  [server session sftp-channel user tmpfile command]
  (let [response (ssh/sftp sftp-channel
                           :put (java.io.ByteArrayInputStream.
                                 (.getBytes (str prolog command))) tmpfile
                           :return-map true)]
    (logging/info (format "Transfering commands %s" response)))
  (let [chmod-result (ssh/ssh
                      session (str "chmod 755 " tmpfile) :return-map true)]
    (if (pos? (chmod-result :exit))
      (logging/error (str "Couldn't chmod script : " ) (chmod-result :err))))
  (let [script-result (ssh/ssh
                       session
                       ;; using :in forces a shell session, rather than
                       ;; exec; some services check for a shell session
                       ;; before detaching (couchdb being one prime
                       ;; example)
                       :in (str (sudo-cmd-for user)
                                " ~" (:username user) "/" tmpfile)
                       :return-map true
                       :pty true)]
    (let [stdout (normalise-eol
                  (strip-sudo-password (script-result :out) user))
          stderr (normalise-eol
                  (strip-sudo-password (get script-result :err "") user))]
      (if (zero? (script-result :exit))
        (logging/info stdout)
        (do
          (logging/error (str "Exit status  : " (script-result :exit)))
          (logging/error (str "Output       : " stdout))
          (logging/error (str "Error output : " stderr))
          (condition/raise
           :message (format
                     "Error executing script :\n :cmd %s\n :out %s\n :err %s"
                     command stdout stderr)
           :type :pallet-script-excution-error
           :script-exit (script-result :exit)
           :script-out stdout
           :script-err stderr
           :server server)))
      (ssh/ssh session (str "rm " tmpfile))
      {:out stdout :err stderr :exit (:exit script-result)})))</pre></tr><tr><td class="docs"><p>Run a sudo command on a server.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn remote-sudo
  [#^String server #^String command user]
  (ssh/with-ssh-agent [(default-agent)]
    (possibly-add-identity
     ssh/*ssh-agent* (:private-key-path user) (:passphrase user))
    (let [session (ssh/session server
                               :username (:username user)
                               :password (:password user)
                               :strict-host-key-checking :no)]
      (ssh/with-connection session
        (let [tmpfile (mktemp session "remotesudo")
              sftp-channel (ssh/ssh-sftp session)]
          (logging/info (format "Cmd %s" command))
          (ssh/with-connection sftp-channel
            (remote-sudo-cmd
             server session sftp-channel user tmpfile command)))))))</pre></tr><tr><td class="docs"><p>Run cmds on a target.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute-ssh-cmds
  [#^String server request user options]
  (ssh/with-ssh-agent [(default-agent)]
    (let [options (apply array-map options)
          session (ssh/session server
                               :username (:username user)
                               :strict-host-key-checking :no
                               :port (or (options :port) 22)
                               :password (:password user))]
      (script/with-template (resource/script-template request)
        (ssh/with-connection session
          (let [tmpfile (mktemp session "sudocmd")
                tmpcpy (mktemp session "tfer")
                sftp-channel (ssh/ssh-sftp session)]
            (ssh/with-connection sftp-channel
              (letfn [(execute
                       [cmdstring]
                       (logging/info (format "Cmd %s" cmdstring))
                       (remote-sudo-cmd
                        server session sftp-channel user tmpfile cmdstring))
                      (from-local
                       [transfers]
                       (doseq [[file remote-name] transfers]
                         (logging/info
                          (format
                           "Transferring file %s to node @ %s via %s"
                           file remote-name tmpcpy))
                         (ssh/sftp sftp-channel
                                   :put (-> file java.io.FileInputStream.
                                            java.io.BufferedInputStream.)
                                   tmpcpy)
                         (remote-sudo-cmd
                          server session sftp-channel user tmpfile
                          (stevedore/script
                           (chmod "0600" ~tmpcpy)
                           (mv -f ~tmpcpy ~remote-name)))))
                      (to-local
                       [transfers]
                       (doseq [[remote-file local-file] transfers]
                         (logging/info
                          (format
                           "Transferring file %s from node to %s"
                           remote-file local-file))
                         (remote-sudo-cmd
                          server session sftp-channel user tmpfile
                          (stevedore/script
                           (cp -f ~remote-file ~tmpcpy)))
                         (ssh/sftp sftp-channel
                                   :get tmpcpy
                                   (-> local-file java.io.FileOutputStream.
                                       java.io.BufferedOutputStream.))))]
                (resource/execute-commands
                 request
                 {:script/bash execute
                  :transfer/to-local to-local
                  :transfer/from-local from-local})))))))))</pre></tr><tr><td class="docs"><p>Execute cmds for the request.
   Also accepts an IP or hostname as anode.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn ssh-cmds
  [{:keys [address commands user ssh-port] :as request}]
  (if commands
    (let [options (if ssh-port [:port ssh-port] [])]
      (execute-ssh-cmds address request user options))
    [nil request]))</pre></tr><tr><td class="docs"><p>Run local cmds on a target.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-cmds
  [#^String commands]
  (let [execute (fn [cmd] ((second cmd)))
        rv (doall (map execute (filter #(= :local (first %)) commands)))]
    rv))</pre></tr><tr><td class="docs"><p>Run a script on local machine.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sh-script
  [command]
  (logging/trace
   (format "sh-script %s" command))
  (let [tmp (java.io.File/createTempFile "pallet" "script")]
    (try
      (io/copy (str prolog command) tmp)
      (shell/sh "chmod" "+x" (.getPath tmp))
      (let [result (shell/sh "bash" (.getPath tmp) :return-map true)]
        (when-not (zero? (:exit result))
          (logging/error
           (format "Command failed: %s\n%s" command (:err result))))
        (logging/info (:out result))
        result)
      (finally  (.delete tmp)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro local-script
  "Run a script on the local machine, setting up stevedore to produce the
   correct target specific code"
  [& body]
  `(script/with-template
     [(jvm/os-family)]
     (sh-script
      (stevedore/script
       ~@body))))</pre></tr><tr><td class="docs"><p>Verify the return code of a sh execution</p>
</td><td class="codes" /><pre class="brush: clojure">(defn verify-sh-return
  [msg cmd result]
  (when-not (zero? (:exit result))
    (condition/raise
     :message (format
               "Error executing script %s\n :cmd %s :out %s\n :err %s"
               msg cmd (:out result) (:err result))
     :type :pallet-script-excution-error
     :script-exit (:exit result)
     :script-out  (:out result)
     :script-err (:err result)
     :server "localhost")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro local-checked-script
  "Run a script on the local machine, setting up stevedore to produce the
   correct target specific code.  The return code is checked."
  [msg & body]
  `(script/with-template
     [(jvm/os-family)]
     (let [cmd# (stevedore/checked-script ~msg ~@body)]
       (verify-sh-return ~msg cmd# (sh-script cmd#)))))</pre></tr><tr><td class="docs"><p>Execute cmds for the request.
   Runs locally as the current user, so useful for testing.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn local-sh-cmds
  [{:keys [commands root-path] :or {root-path "/tmp/"} :as request}]
  (if commands
    (letfn [(execute-bash
             [cmdstring]
             (logging/info (format "Cmd %s" cmdstring))
             (sh-script cmdstring))
            (transfer
             [transfers]
             (doseq [[from to] transfers]
               (logging/info (format "Copying %s to %s" from to))
               (io/copy (io/file from) (io/file to))))]
      (resource/execute-commands
       request
       {:script/bash execute-bash
        :transfer/to-local transfer
        :transfer/from-local transfer}))
    [nil request]))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.heynote" name="pallet.heynote"><h1 class="project-name">pallet.heynote</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Heynote feedback client</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.heynote
  (:require
   [clojure.contrib.logging :as logging]
   [clojure.contrib.http.agent :as agent]
   [clojure.contrib.http.connection :as connection]
   [clojure.contrib.json :as json]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce heynote-project (atom nil))</pre></tr><tr><td class="docs"><p>Sets and returns the heynote project name</p>
</td><td class="codes" /><pre class="brush: clojure">(defn project
  [name]
  (reset! heynote-project name))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def heynote-url "http://orcloud-heynote.appspot.com/")</pre></tr><tr><td class="docs"><p>(def heynote-url "http://localhost:8080/")</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def user-prefs (atom nil))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def user-prefs-file
     (str (. System getProperty "user.home") "/.heynote"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- user-preferences
  [& options]
  (when-not @user-prefs
    (try
     (reset! user-prefs (read-string (slurp user-prefs-file)))
     (catch Exception e
       (reset! user-prefs {}))))
  (when (seq options)
    (swap! user-prefs merge (apply hash-map options))
    (spit user-prefs-file (with-out-str (pr @user-prefs))))
  @user-prefs)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- process-response
  [response]
  (when (nil? ((user-preferences) :id))
    (user-preferences :id (response :user-id))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- read-response
  "Read heynote response."
  [http-agnt]
  (let [ response (json/read-json
                   (java.io.PushbackReader.
                    (java.io.InputStreamReader.
                     (agent/stream http-agnt))))]
    (process-response response)
    response))</pre></tr><tr><td class="docs"><p>Send the given message map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn send-msg
  [path method msg-map]
  (let [agent (agent/http-agent
               (str heynote-url path)
               :method method
               :body (json/json-str msg-map)
               :headers {"Content-type" "application/json"}
               :handler read-response)
        response (agent/result agent)]
    (println
     (if (agent/client-error? agent)
       "There was a problem with the feedback system."))
    response))</pre></tr><tr><td class="docs"><p>Return a map that can be used to send to heynote</p>
</td><td class="codes" /><pre class="brush: clojure">(defn message-map
  []
  (when-not @heynote-project
    (throw (java.lang.RuntimeException. "No heynote project configured")))
  {:project @heynote-project
   :user-id (:id (user-preferences))})</pre></tr><tr><td class="docs"><p>Send new feedback with the given message</p>
</td><td class="codes" /><pre class="brush: clojure">(defn new-item
  [& options]
  (let [response (send-msg
                  "item/new" "POST"
                  (merge (message-map) (apply hash-map options)))]
    (println (response :item))))</pre></tr><tr><td class="docs"><p>Recieve feedback items</p>
</td><td class="codes" /><pre class="brush: clojure">(defn items
  [& options]
  (let [response (send-msg
                  "items" "GET"
                  (merge (message-map) (apply hash-map options)))
        items (response :items [])]
    (doseq [item items]
      (println item))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn as-number-if-possible [x]
  (if (string? x)
    (try
      (Long/parseLong x)
      (catch NumberFormatException e
        x))
    x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn as-string
  [x]
  (cond
   (keyword? x) (name x)
   (symbol? x) (name x)
   :else (str x)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn item-id-from-string
  [item]
  (as-number-if-possible
   (.substring (as-string item) 1)))</pre></tr><tr><td class="docs"><p>Recieve feedback item</p>
</td><td class="codes" /><pre class="brush: clojure">(defn item
  [item & options]
  (let [response (send-msg
                  "item" "GET"
                  (-> (message-map)
                      (merge (apply hash-map options))
                      (assoc :item-id (item-id-from-string item))))
        item (response :item)
        comments (response :comments [])]
    (println item)
    (doseq [comment comments]
      (println comment))))</pre></tr><tr><td class="docs"><p>Receive feedback items</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-comment
  [item & options]
  (let [response (send-msg
                  "comment" "POST"
                  (-> (message-map)
                      (merge (apply hash-map options))
                      (assoc :item-id (item-id-from-string item))))
        comment (response :item "There was a problem adding your comment.")]
    (println comment)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main" name="pallet.main"><h1 class="project-name">pallet.main</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.main
  (:gen-class)
  (:require
   clojure.walk
   [pallet.command-line :as command-line]
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>An exception instance to use for terminating the task, without
          a stack trace</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc }
  exit-task-exception (Exception.))</pre></tr><tr><td class="docs"><p>Report a message to <em>err</em>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn report-error
  [msg]
  (binding [*out* *err*]
    (println msg)))</pre></tr><tr><td class="docs"><p>Abort a task, with the specified error message, and no stack trace.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn abort
  [msg]
  (report-error msg)
  (throw exit-task-exception))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn read-targets
  ([dir]
     (try
      (doseq [file (file-seq dir)]
        (load (.getPath file)))
      (catch java.io.FileNotFoundException _
        (abort "No pallet directory found in the current directory."))))
  ([] (read-targets "pallet")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def aliases {"--help" "help" "-h" "help" "-?" "help" "-v" "version"
              "--version" "version"})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resolve-task [task]
  (let [task-ns (symbol (str "pallet.task." task))
        task (symbol task)
        error-fn (with-meta
                   (fn [& _]
                     (abort
                      (format
                       "%s is not a task. Use \"help\" to list all tasks."
                       task)))
                   {:no-service-required true})]
    (try
      (when-not (find-ns task-ns)
        (require task-ns))
      (or (ns-resolve task-ns task)
          error-fn)
      (catch java.io.FileNotFoundException e
        error-fn))))</pre></tr><tr><td class="docs"><p>Convert the given string into a namespace qualified symbol.
   Returns a vector of ns and symbol</p>
</td><td class="codes" /><pre class="brush: clojure">(defn parse-as-qualified-symbol
  [arg]
  {:pre [(string? arg)]}
  (if (.contains arg "/")
    (if-let [sym (symbol arg)]
      [(symbol (namespace sym)) sym])))</pre></tr><tr><td class="docs"><p>Function to build a symbol->value map, requiring namespaces as needed.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn map-and-resolve-symbols
  [symbol-map arg]
  (if-let [[ns sym] (parse-as-qualified-symbol arg)]
    (do
      (try
        (require ns)
        (catch java.io.FileNotFoundException e
          (abort
           (format "Could not locate node definition for %s" arg))))
      (if-let [v (find-var sym)]
        (assoc symbol-map sym (var-get v))
        symbol-map))
    symbol-map))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn profiles
  [profiles-string]
  (when profiles-string
    (string/split profiles-string #",")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- report-unexpected-exception
  "Check the exception to see if it is the `exit-task-exception`, and if it is
   not, then report the exception."
  [^Throwable e]
  (when-not (= e exit-task-exception)
    (report-error (.getMessage e))
    (.printStackTrace e (java.io.PrintWriter. *err*))))</pre></tr><tr><td class="docs"><p>A pallet task.</p>

<p>   Returns an integer exit status suitable for System/exit.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pallet-task
  [args]
  (command-line/with-command-line args
    "Pallet command line"
    [[provider "Cloud provider name."]
     [identity "Cloud user name or key."]
     [credential "Cloud password or secret."]
     [blobstore-provider "Blobstore provider name."]
     [blobstore-identity "Blobstore user name or key."]
     [blobstore-credential "Blobstore password or secret."]
     [P "Profiles to use for key lookup in config.clj or settings.xml"]
     [project-options "Project options (usually picked up from project.clj)."]
     [defaults "Default options (usually picked up from config.clj)."]
     args]
    (try
      (let [[task & args] args
            task (or (aliases task) task "help")
            project-options (when project-options
                              (read-string project-options))
            defaults (when defaults
                       (read-string defaults))
            symbol-map (reduce map-and-resolve-symbols {} args)
            arg-line (str "[ " (apply str (interpose " " args)) " ]")
            params (read-string arg-line)
            params (clojure.walk/prewalk-replace symbol-map params)
            task (resolve-task task)
            return-value (if (:no-service-required (meta task))
                           (apply task params)
                           (let [_ (require 'pallet.main-invoker)
                                 invoker (find-var
                                          'pallet.main-invoker/invoke)]
                             (invoker
                              {:provider provider
                               :identity identity
                               :credential credential
                               :blobstore-provider blobstore-provider
                               :blobstore-identity blobstore-identity
                               :blobstore-credential blobstore-credential
                               :profiles (profiles P)
                               :project project-options
                               :defaults defaults}
                              task
                              params)))]
        (flush)
        (if (integer? return-value) return-value 0))
      (catch Exception e
        (report-unexpected-exception e)
        1))))</pre></tr><tr><td class="docs"><p>Command line runner.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn -main
  ([& args]
     (let [return-value (pallet-task args)]
       (shutdown-agents)
       (System/exit return-value)))
  ([] (apply -main *command-line-args*)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.main-invoker" name="pallet.main-invoker"><h1 class="project-name">pallet.main-invoker</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Invoke tasks requiring a compute service.  This decouples main from anything
   pallet, jclouds or maven specific, and ensures compiling main doesn't compile
   the world.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.main-invoker
  (:require
   [clojure.contrib.logging :as logging]
   [pallet.compute :as compute]
   [pallet.configure :as configure]
   [pallet.blobstore :as blobstore]
   [pallet.utils :as utils]
   [pallet.main :as main]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn log-info
  [admin-user]
  (logging/debug (format "OS              %s %s"
                         (System/getProperty "os.name")
                         (System/getProperty "os.version")))
  (logging/debug (format "Arch            %s" (System/getProperty "os.arch")))
  (logging/debug (format "Admin user      %s" (:username admin-user)))
  (let [private-key-path (:private-key-path admin-user)
        public-key-path (:public-key-path admin-user)]
    (logging/debug
     (format "private-key-path %s %s" private-key-path
             (.canRead (java.io.File. private-key-path))))
    (logging/debug
     (format "public-key-path %s %s" public-key-path
             (.canRead (java.io.File. public-key-path))))))</pre></tr><tr><td class="docs"><p>Return the admin user</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-admin-user
  [defaults project profiles]
  (or
   (utils/admin-user-from-config (:pallet project))
   (utils/admin-user-from-config defaults)
   (utils/admin-user-from-config-var)
   utils/*admin-user*))</pre></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property,
     check maven settings,
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-compute-service
  [options defaults project profiles]
  (or
   (compute/compute-service-from-map options)
   (compute/compute-service-from-config (:pallet project) profiles)
   (compute/compute-service-from-config defaults profiles)
   (compute/compute-service-from-property)
   (apply compute/compute-service-from-settings profiles)
   (compute/compute-service-from-config-var)))</pre></tr><tr><td class="docs"><p>Look for a compute service in the following sequence:
     Check pallet.config.service property,
     check maven settings,
     check pallet.config/service var.
   This sequence allows you to specify an overridable default in
   pallet.config/service.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-blobstore
  [options defaults project profiles]
  (or
   (blobstore/blobstore-from-map options)
   (blobstore/blobstore-from-config (:pallet project) profiles)
   (blobstore/blobstore-from-config defaults profiles)
   (apply blobstore/blobstore-from-settings profiles)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn invoke
  [options task params]
  (let [default-config (or (:defaults options) (configure/pallet-config))
        admin-user (find-admin-user
                    default-config (:project options) (:profiles options))
        compute (find-compute-service
                 options default-config
                 (:project options) (:profiles options))]
    (if compute
      (try
        (let [blobstore (find-blobstore
                         options default-config
                         (:project options) (:profiles options))]
          (try
            (log-info admin-user)
            (apply task {:compute compute
                         :blobstore blobstore
                         :project (:project options)
                         :config default-config
                         :user admin-user} params)
            (finally ;; make sure we don't hang on exceptions
             (when blobstore
               (blobstore/close blobstore)))))
        (finally ;; make sure we don't hang on exceptions
         (compute/close compute)))
      (do
        (println "Error: no credentials supplied\n\n")
        ((main/resolve-task "help"))
        1))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.maven" name="pallet.maven"><h1 class="project-name">pallet.maven</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Maven interaction</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.maven
  (:import
   [org.apache.maven.settings Settings MavenSettingsBuilder]
   [org.codehaus.plexus.embed Embedder]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def key-map
  {:pallet.compute.provider :provider
   :pallet.compute.identity :identity
   :pallet.compute.credential :credential
   :pallet.compute.extensions :extensions
   :pallet.blobstore.provider :blobstore-provider
   :pallet.blobstore.identity :blobstore-identity
   :pallet.blobstore.credential :blobstore-credential
   :pallet.blobstore.extensions :blobstore-extensions
   :pallet.endpoint :endpoint
   :jclouds.compute.provider :provider
   :jclouds.compute.identity :identity
   :jclouds.compute.credential :credential
   :jclouds.compute.extensions :extensions
   :jclouds.blobstore.provider :blobstore-provider
   :jclouds.blobstore.identity :blobstore-identity
   :jclouds.blobstore.credential :blobstore-credential
   :jclouds.endpoint :endpoint})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def container (.getContainer (doto (Embedder.) (.start))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- make-settings []
  (.buildSettings (.lookup container MavenSettingsBuilder/ROLE)))</pre></tr><tr><td class="docs"><p>Read maven's settings.xml file, and extract properties from active profiles
   as a map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn properties
  [profiles]
  (let [settings (make-settings)
        properties (apply
                    merge
                    (map #(into {} (.getProperties (val %)))
                         (select-keys
                          (into {} (.getProfilesAsMap settings))
                          (if (seq profiles)
                            profiles
                            (.getActiveProfiles settings)))))]
    (zipmap (map keyword (keys properties)) (vals properties))))</pre></tr><tr><td class="docs"><p>Read maven's settings.xml file, and extract credentials.  </p>
</td><td class="codes" /><pre class="brush: clojure">(defn credentials
  [profiles]
  (into {}
        (filter identity
                (map
                 #(if-let [k (key-map (key %))] [k (val %)])
                 (properties profiles)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.md5crypt" name="pallet.md5crypt"><h1 class="project-name">pallet.md5crypt</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.md5crypt
  (:import [java.security NoSuchAlgorithmException MessageDigest]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce salt-chars
  "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce itoa64
  "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce md5-magic "$1$")
(defonce apache-magic "$apr1$")</pre></tr><tr><td class="docs"><p>Return value encoded as n base64 chars</p>
</td><td class="codes" /><pre class="brush: clojure">(defn to64
  [#^Integer value #^Integer n]
  (if (pos? n)
    (str (.charAt itoa64 (int (bit-and value 0x3f)))
         (to64 (bit-shift-right value 6) (dec n)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn salt
  []
  (apply str (take 8 (repeatedly #(rand-nth itoa64)))))</pre></tr><tr><td class="docs"><p>Clean up a passed salt value</p>
</td><td class="codes" /><pre class="brush: clojure">(defn #^String clean-salt
  [#^String salt #^String magic]
  (let [salt (if (.startsWith salt magic)
                (.substring salt (.length magic))
                salt)
        salt (if (.contains salt "$")
               (.substring salt 0 (.indexOf salt "$"))
               salt)
        salt (if (> (.length salt) 8)
               (.substring salt 0 8)
               salt)]
    salt))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn set-array [#^bytes array #^Byte value]
  (dotimes [i (alength array)]
    (aset array i value))
  array)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn #^Integer byte-as-unsigned
  [b]
  (int (bit-and (int (byte b)) 0xff)))</pre></tr><tr><td class="docs"><p>LINUX/BSD MD5Crypt function</p>
</td><td class="codes" /><pre class="brush: clojure">(defn crypt
  ([password]
     (crypt password (salt) md5-magic))
  ([password salt]
     (crypt password salt md5-magic))
  ([#^String password #^String salt #^String magic]
     (let [salt (clean-salt salt magic)
           ctx (doto (MessageDigest/getInstance "md5")
                 (.update (.getBytes password))
                 (.update (.getBytes magic))
                 (.update (.getBytes salt)))
           ctx1 (doto (MessageDigest/getInstance "md5")
                  (.update (.getBytes password))
                  (.update (.getBytes salt))
                  (.update (.getBytes password)))
           final-state (.digest ctx1)]
       (loop [l (.length password)]
         (.update ctx final-state 0 (min l 16))
         (if (> l 16)
           (recur (int (- l 16)))))
       (set-array final-state (byte 0))
       (loop [i (.length password)]
         (when (pos? i)
           (if (pos? (bit-and i 1))
             (.update ctx final-state 0 1)
             (.update ctx (.getBytes password) 0 1))
           (recur (bit-shift-right i 1))))
       (let [#^bytes final-state (loop [final-state (.digest ctx)
                                i 0]
                           (if (< i 1000)
                             (let [ctx1 (MessageDigest/getInstance "md5")]
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 (.getBytes password))
                                 (.update ctx1 final-state 0 16))
                               (if (pos? (mod i 3))
                                 (.update ctx1 (.getBytes salt)))
                               (if (pos? (mod i 7))
                                 (.update ctx1 (.getBytes password)))
                               (if (pos? (bit-and i 1))
                                 (.update ctx1 final-state 0 16)
                                 (.update ctx1 (.getBytes password)))
                               (recur (.digest ctx1) (inc i)))
                             final-state))]
         (str
          magic
          salt
          "$"
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 0)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 6)) 8))
                 (byte-as-unsigned (aget final-state 12)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 1)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 7)) 8))
                 (byte-as-unsigned (aget final-state 13)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 2)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 8)) 8))
                 (byte-as-unsigned (aget final-state 14)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 3)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 9)) 8))
                 (byte-as-unsigned (aget final-state 15)))
                4)
          (to64 (bit-or
                 (bit-or
                  (bit-shift-left (byte-as-unsigned (aget final-state 4)) 16)
                  (bit-shift-left (byte-as-unsigned (aget final-state 10)) 8))
                 (byte-as-unsigned (aget final-state 5)))
                4)
          (to64 (byte-as-unsigned (aget final-state 11)) 2))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.parameter" name="pallet.parameter"><h1 class="project-name">pallet.parameter</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provides functions for working with parameters.</p>

<p>   Parameters are data maps that allow propogation of information between the
   functions of a crate, and between crates. There are two conventions for using
   parameters in crates that are directly supported here.</p>

<p>   Host specific parameters are specified under
       [:parameters :host (keyword target-id)]
   These functions are <code>get-for-target</code>, <code>assoc-for-target</code>, and
   <code>update-for-target</code>.</p>

<p>   Service specific paramters, used across hosts, are specified under
      [:parameters :service (keyword service-name)]
   These functions are <code>get-for-service</code>, <code>assoc-for-service</code>, and
   <code>update-for-service</code>.</p>

<p>   The <code>get-for</code> functions have slightly different semantics compared with
   clojure.core/get, in that they throw an exception if the key is undefined
   and no default value is specified.</p>

<p>   Delayed evaluation of parameters specified as arguments to resource functions
   are also implemented here. <code>lookup</code> and <code>lookup-for-target</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.parameter
  (:require
   [pallet.argument :as argument]
   [pallet.resource :as resource]
   [clojure.contrib.condition :as condition]))</pre></tr><tr><td class="docs"><p>Initialise parameters based on the given keys, which are used to merge maps
   from m.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn from-map
  [m keys]
  (reduce merge {} (map m keys)))</pre></tr><tr><td class="docs"><p>Retrieve the parameter at the path specified by keys.
   When no default value is specified, then raise a :parameter-not-found if no
   parameter is set.</p>

<pre><code>   (get-for {:p {:a {:b 1} {:d 2}}} [:p :a :d])
     =&gt; 2
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn get-for
  ([request keys]
     (let [result (get-in (:parameters request) keys ::not-set)]
       (when (= ::not-set result)
         (condition/raise
          :type :parameter-not-found
          :message (format
                    "Could not find keys %s in request :parameters"
                    (if (sequential? keys) (vec keys) keys))
          :key-not-set keys))
       result))
  ([request keys default]
       (get-in (:parameters request) keys default)))</pre></tr><tr><td class="docs"><p>Retrieve the host parameter for the current target at the path specified by
   keys.  When no default value is specified, then raise a :parameter-not-found
   if no parameter is set.</p>

<pre><code>   (get-for-target
     {:parameters {:host {:id1 {:a {:b 1} {:d 2}}}}
      :target-id :id1} [:a :b])
     =&gt; 1
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn get-for-target
  ([request keys]
     (get-for request (concat [:host (:target-id request)] keys)))
  ([request keys default]
     (get-for request (concat [:host (:target-id request)] keys) default)))</pre></tr><tr><td class="docs"><p>Retrieve the service parameter for the service and path specified by
   keys.  When no default value is specified, then raise a :parameter-not-found
   if no parameter is set.</p>

<pre><code>   (get-for-service
     {:parameters {:service {:proxy {:a {:b 1} {:d 2}}}}} [:proxy :a :b])
     =&gt; 1
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn get-for-service
  ([request keys]
     (get-for request (concat [:service] keys)))
  ([request keys default]
     (get-for request (concat [:service] keys) default)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- assoc-for-prefix
  "Set the values in a map at the paths specified with prefix prepended to each
   path.

       (assoc-for-prefix {} :prefix [:a :b] 1 [:a :d] 2)
         => {:prefix {:a {:b 1} {:d 2}}}"
  [request prefix {:as keys-value-pairs}]
  (reduce
   #(assoc-in %1 (concat prefix (first %2)) (second %2))
   request
   keys-value-pairs))</pre></tr><tr><td class="docs"><p>Set the :parameters values at the paths specified.</p>

<pre><code>   (assoc-for {} [:a :b] 1 [:a :d] 2)
     =&gt; {:parameters {:a {:b 1} {:d 2}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for
  [request & {:as keys-value-pairs}]
  (assoc-for-prefix request [:parameters] keys-value-pairs))</pre></tr><tr><td class="docs"><p>Set the host parameter values at the paths specified.</p>

<pre><code>   (assoc-for-target {:target-id :id1} [:a :b] 1 [:a :d] 2)
     =&gt; {:parameters {:host {:id1 {:a {:b 1} {:d 2}}}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for-target
  [request & {:as keys-value-pairs}]
  (assoc-for-prefix
   request [:parameters :host (:target-id request)] keys-value-pairs))</pre></tr><tr><td class="docs"><p>Set the service parameter values at the paths specified.</p>

<pre><code>   (assoc-for-service {} :proxy [:a :b] 1 [:a :d] 2)
     =&gt; {:parameters {:srvice {:proxy {:a {:b 1} {:d 2}}}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn assoc-for-service
  [request service & {:as keys-value-pairs}]
  (assoc-for-prefix
   request [:parameters :service service] keys-value-pairs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- update-for-prefix
  "Update a map at the path given by the prefix and keys.
   The value is set to the value return by calling f with the current
   value and the given args.

       (update-for-prefix {:p {:a {:b 1}}} [:p] [:a :b] + 2)
         => {:p {:a {:b 3}}}"
  ([request prefix keys f args]
  (apply update-in request (concat prefix keys) f args)))</pre></tr><tr><td class="docs"><p>Update parameters at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.</p>

<pre><code>   (update-for {:parameters {:a {:b 1}}} [:a :b] + 2)
     =&gt; {:parameters {:a {:b 3}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn update-for
  ([request keys f & args]
     (update-for-prefix request [:parameters] keys f args)))</pre></tr><tr><td class="docs"><p>Update host parameters for the current target at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.</p>

<pre><code>   (update-for-target
      {:parameters {:host {:id1 {:a {:b 1}}}}
       :target-id :id1}
      [:a :b] + 2)
     =&gt; {:parameters {:host {:id1 {:a {:b 3}}}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn update-for-target
  [request keys f & args]
  (update-for-prefix
   request [:parameters :host (:target-id request)] keys f args))</pre></tr><tr><td class="docs"><p>Update serivce parameters for the pecified service at the path given by keys.
   The value is set to the value return by calling f with the current
   value and the given args.</p>

<pre><code>   (update-for-service
      {:parameters {:service {:proxy {:a {:b 1}}}}}
      [:proxy :a :b] + 2)
     =&gt; {:parameters {:service {:proxy {:a {:b 3}}}}}
</code></pre>
</td><td class="codes" /><pre class="brush: clojure">(defn update-for-service
  [request keys f & args]
  (update-for-prefix request [:parameters :service] keys f args))</pre></tr><tr><td class="docs"><p>Delayed parameter evaluation</p>
</td><td class="codes" /><pre class="brush: clojure">(deftype ParameterLookup
  [keys]
  pallet.argument.DelayedArgument
  (evaluate
   [_ request]
   (get-for request keys)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deftype ParameterLookupTarget
  [keys]
  pallet.argument.DelayedArgument
  (evaluate
   [_ request]
   (get-for request (concat [:host (:target-id request)] keys))))</pre></tr><tr><td class="docs"><p>Lookup a parameter in a delayed manner. Use a call to this function as the
   argument of a resource.
   This function produces an object, which causes parameter lookup when it's
   toString method is called.</p>

<p>   See also <code>pallet.argument</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn lookup
  [& keys]
  (ParameterLookup. keys))</pre></tr><tr><td class="docs"><p>Lookup a parameter for the target in a delayed manner. Use a call to this
   function as the argument of a resource.  This function produces an object,
   which causes parameter lookup when it's toString method is called.</p>

<p>   See also <code>pallet.argument</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn lookup-for-target
  [& keys]
  (ParameterLookupTarget. keys))</pre></tr><tr><td class="docs"><p>Resources</p>
</td><td class="codes" /><pre class="brush: clojure">(resource/deflocal parameters
  "A resource to set parameters"
  (parameters* [request & {:as keyvector-value-pairs}]
   (assoc request
     :parameters (reduce
                  #(apply assoc-in %1 %2)
                  (:parameters request)
                  keyvector-value-pairs))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.repl" name="pallet.repl"><h1 class="project-name">pallet.repl</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A namespace that can be used to pull in most of pallet's namespaces.  uesful
  when working at the clojure REPL.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.repl
  (:use
   [org.jclouds.compute
    :exclude [destroy-node nodes run-nodes destroy-nodes-with-tag
              terminated? id running? tag hostname compute-service]]
   pallet.utils
   [pallet.compute :exclude [make-node]]
   pallet.core
   pallet.resource
   pallet.resource.package
   pallet.task.feedback
   clj-ssh.ssh))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro use-pallet
  "Macro that will use pallet's namespaces, to provide an easy to access REPL."
  []
  '(do
     (clojure.core/use
      '[org.jclouds.compute
        :exclude [destroy-node nodes run-nodes destroy-nodes-with-tag
                  terminated? id running? tag hostname compute-service]]
      'pallet.utils
      '[pallet.compute :exclude [make-node]]
      'pallet.core
      'pallet.resource
      'pallet.resource.package
      'pallet.task.feedback
      'clj-ssh.ssh)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.request-map" name="pallet.request-map"><h1 class="project-name">pallet.request-map</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions for querying and manipulating requests</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.request-map
  (:require
   [pallet.compute :as compute])
  (:use
   [clojure.contrib.core :only [-?>]])
  (:import
   (java.security
    NoSuchAlgorithmException
    MessageDigest)
   (org.apache.commons.codec.binary Base64)))</pre></tr><tr><td class="docs"><p>Computes a configuration and filesystem safe identifier corresponding to a
  potentially unsafe ID</p>
</td><td class="codes" /><pre class="brush: clojure">(defn safe-id
  [#^String unsafe-id]
  (let [alg (doto (MessageDigest/getInstance "MD5")
              (.reset)
              (.update (.getBytes unsafe-id)))]
    (try
      (Base64/encodeBase64URLSafeString (.digest alg))
      (catch NoSuchAlgorithmException e
        (throw (new RuntimeException e))))))</pre></tr><tr><td class="docs"><p>Name of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-name
  [request]
  (compute/hostname (:target-node request)))</pre></tr><tr><td class="docs"><p>Id of the target-node (unique for provider).</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-id
  [request]
  (compute/id (:target-node request)))</pre></tr><tr><td class="docs"><p>IP of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn target-ip
  [request]
  (compute/primary-ip (:target-node request)))</pre></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-family
  [request]
  (-> request :node-type :image :os-family))</pre></tr><tr><td class="docs"><p>OS-Family of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-version
  [request]
  (-> request :node-type :image :os-version))</pre></tr><tr><td class="docs"><p>Tag of the target-node.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tag
  [request]
  (-> request :node-type :tag))</pre></tr><tr><td class="docs"><p>Safe name for target machine.
   Some providers don't allow for node names, only node ids, and there is
   no guarantee on the id format.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn safe-name
  [request]
  (format "%s%s" (name (tag request)) (safe-id (target-id request))))</pre></tr><tr><td class="docs"><p>All nodes in the same tag as the target-node, or with the specified tag.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn nodes-in-tag
  ([request] (nodes-in-tag request (tag request)))
  ([request tag]
     (filter #(= (name tag) (compute/tag %)) (:target-nodes request))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn packager
  [request]
  (compute/packager (-?> request :node-type :image)))</pre></tr><tr><td class="docs"><p>Find the script template keys for the request</p>
</td><td class="codes" /><pre class="brush: clojure">(defn script-template-keys
  [request]
  (let [node (:target-node request)]
    (distinct
     (filter
      identity
      [(-?> (.. node operatingSystem family) keyword str)
       (-?> (.. node operatingSystem version) keyword str)
       (-?> (.. node operatingSystem description) keyword str)]))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.directory" name="pallet.resource.directory"><h1 class="project-name">pallet.resource.directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A directory manipulation resource, to create and remove directories
   with given ownership and mode.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.directory
  (:require
   [pallet.utils :as utils]
   [pallet.stevedore :as stevedore]
   [pallet.script :as script])
  (:use
   [pallet.resource :only [defresource]]
   [pallet.resource.file :only [chown chgrp chmod]]
   clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript rmdir
  "Remove the specified directory"
  [directory & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl rmdir :default [directory & options]
  ("rmdir" ~(stevedore/map-to-arg-string (first options)) ~directory))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript mkdir
  "Create the specified directory"
  [directory & options])
(stevedore/defimpl mkdir :default [directory & options]
  ("mkdir" ~(stevedore/map-to-arg-string (first options)) ~directory))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript make-temp-dir
  "Create a temporary directory"
  [pattern & options])
(stevedore/defimpl make-temp-dir :default [pattern & options]
  @("mktemp" -d
    ~(stevedore/map-to-arg-string (first options))
    ~(str pattern "XXXXX")))</pre></tr><tr><td class="docs"><p>Script to set the ownership and mode of a directory.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn adjust-directory
  [path opts]
  (stevedore/chain-commands*
   (filter
    (complement nil?)
    [(when (opts :owner)
       (stevedore/script
        (chown ~(opts :owner) ~path  ~(select-keys opts [:recursive]))))
     (when (opts :group)
       (stevedore/script
        (chgrp ~(opts :group) ~path  ~(select-keys opts [:recursive]))))
     (when (opts :mode)
       (stevedore/script
        (chmod ~(opts :mode) ~path  ~(select-keys opts [:recursive]))))])))</pre></tr><tr><td class="docs"><p>Script to create a directory.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-directory
  [path opts]
  (stevedore/checked-commands
   (str "Directory " path)
   (stevedore/script
    (mkdir ~path ~(select-keys opts [:p :v :m])))
   (adjust-directory path opts)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource directory
  "Directory management.

   For :create and :touch, all components of path are effected.

   Options are:
    - :action     One of :create, :touch, :delete
    - :recursive  Flag for recursive delete
    - :force      Flag for forced delete"
  (directory*
   [request path & {:keys [action] :or {action :create} :as options}]
   (case action
     :delete (stevedore/checked-script
              (str "Delete directory " path)
              (rm ~path ~{:r (get options :recursive true)
                          :f (get options :force true)}))
     :create (make-directory path (merge {:p true} options))
     :touch (make-directory path (merge {:p true} options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource directories
  "Directory management of multiple directories with the same
   owner/group/permissions.

   `options` are as for `directory` and are applied to each directory in
   `paths`"
  (directories*
   [request paths & options]
   (stevedore/chain-commands*
    (map #(apply directory* request % options) paths))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.exec-script" name="pallet.resource.exec-script"><h1 class="project-name">pallet.resource.exec-script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Script execution. script generation is delayed until resource application
   time, so that it occurs wirh the correct target.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.exec-script
  (:require
   [pallet.resource :as resource]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(resource/defresource exec-script*
  (exec-script-fn**
   [request script]
   script))</pre></tr><tr><td class="docs"><p>these can only be used within a phase macro</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-script [request & script]
  `(exec-script* ~request (stevedore/script ~@script)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro exec-checked-script [request name & script]
  `(exec-script* ~request (stevedore/checked-script ~name ~@script)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.file" name="pallet.resource.file"><h1 class="project-name">pallet.resource.file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>File manipulation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.file
  (:require
   [pallet.utils :as utils]
   [pallet.stevedore :as stevedore]
   [pallet.resource.file :as file]
   [pallet.script :as script]
   [clojure.string :as string])
  (:use
   [pallet.resource :only [defresource]]
   clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript rm [file & options])
(stevedore/defimpl rm :default [file & options]
  ("rm" ~(stevedore/map-to-arg-string (first options)) ~file))
(stevedore/defimpl rm [#{:darwin :os-x}] [file & options]
  ("rm" ~(stevedore/map-to-arg-string
          {:r (:recursive (first options))
           :f (:force (first options))}) ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chown [owner file & options])
(stevedore/defimpl chown :default [owner file & options]
  ("chown" ~(stevedore/map-to-arg-string (first options)) ~owner ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chgrp [group file & options])
(stevedore/defimpl chgrp :default [group file & options]
  ("chgrp" ~(stevedore/map-to-arg-string (first options)) ~group ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript chmod [mode file & options])
(stevedore/defimpl chmod :default [mode file & options]
  ("chmod" ~(stevedore/map-to-arg-string (first options)) ~mode ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript touch [file & options])
(stevedore/defimpl touch :default [file & options]
  ("touch" ~(stevedore/map-to-arg-string (first options)) ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript md5sum [file & {:as options}])
(stevedore/defimpl md5sum :default [file & {:as options}]
  ("md5sum" ~(stevedore/map-to-arg-string options) ~file))
(stevedore/defimpl md5sum [#{:darwin :os-x}] [file & {:as options}]
  ("/sbin/md5" -r ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript md5sum-verify [file & {:as options}])
(stevedore/defimpl md5sum-verify :default
  [file & {:keys [quiet check] :or {quiet true check true} :as options}]
  (chain-and
   (cd @(dirname ~file))
   ("md5sum"
    ~(stevedore/map-to-arg-string {:quiet quiet :check check})
    @(basename ~file))
   (cd -)))
(stevedore/defimpl md5sum-verify [#{:centos :debian :amzn-linux :rhel}]
  [file & {:keys [quiet check] :or {quiet true check true} :as options}]
  (chain-and
   (cd @(dirname ~file))
   ("md5sum"
    ~(stevedore/map-to-arg-string {:status quiet :check check})
    @(basename ~file))
   (cd -)))
(stevedore/defimpl md5sum-verify [#{:darwin :os-x}] [file & {:as options}]
  (chain-and
   (var testfile @(cut -d "' '" -f 2 ~file))
   (var md5 @(cut -d "' '" -f 1 ~file))
   (test (quoted @("/sbin/md5" -q @testfile)) == (quoted @md5))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript backup-option [])
(stevedore/defimpl backup-option :default []
  "--backup=numbered")
(stevedore/defimpl backup-option [#{:darwin :os-x}] []
  "")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript sed-file [file expr-map options])</pre></tr><tr><td class="docs"><p>Possible sed separators</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:doc  :private true}
  sed-separators
  (concat [\/ \_ \| \: \% \! \@] (map char (range 42 127))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl sed-file :default
  [file expr-map {:keys [seperator restriction] :as options}]
  ("sed" "-i"
   ~(if (map? expr-map)
      (string/join
       " "
       (map
        (fn [[key value]]
          (let [used (fn [c]
                       (or (>= (.indexOf key (int c)) 0)
                           (>= (.indexOf value (int c)) 0)))
                seperator (or seperator (first (remove used sed-separators)))]
            (format
             "-e \"%ss%s%s%s%s%s\""
             (if restriction (str restriction " ") "")
             seperator key seperator value seperator)))
        expr-map))
      (format "-e \"%s%s\"" (when restriction (str restriction " ")) expr-map))
   ~file))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript download-file [url path & {:keys [proxy]}])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl download-file :default [url path & {:keys [proxy]}]
  (if (test @(which curl))
    ("curl" "-o" (quoted ~path)
     --retry 5 --silent --show-error --fail --location
     ~(if proxy
        (let [url (java.net.URL. proxy)]
          (format "--proxy %s:%s" (.getHost url) (.getPort url)))
        "")
     (quoted ~url))
    (if (test @(which wget))
      ("wget" "-O" (quoted ~path) --tries 5 --no-verbose
       ~(if proxy
          (format "-e \"http_proxy = %s\" -e \"ftp_proxy = %s\"" proxy proxy)
          "")
       (quoted ~url))
      (do
        (println "No download utility available")
        (exit 1)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript download-request [path request])
(stevedore/defimpl download-request :default [path request]
  ("curl" "-o" (quoted ~path) --retry 3 --silent --show-error --fail --location
   ~(string/join
     " "
     (map (fn dlr-fmt [e] (format "-H \"%s: %s\"" (key e) (val e)))
          (:headers request)))
   (quoted ~(:endpoint request))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript tmp-dir [])
(stevedore/defimpl tmp-dir :default []
  @TMPDIR-/tmp)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript make-temp-file [pattern])
(stevedore/defimpl make-temp-file :default [pattern]
  @(mktemp (quoted ~(str pattern "XXXXX"))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript heredoc [path content])
(stevedore/defimpl heredoc :default [path content]
  ("{ cat" ">" ~path ~(str "<<EOFpallet\n" content "\nEOFpallet\n }")))</pre></tr><tr><td class="docs"><p>Generates a heredoc. Options:
      :literal boolean  - if true, prevents shell expansion of contents</p>

<p>the cat is wrapped in braces so that the final newline is protected</p>
</td><td class="codes" /><pre class="brush: clojure">(defn heredoc
  [path content & options]
  (let [options (apply hash-map options)]
    (stevedore/script ("{ cat" ">" ~path
             ~(str (if (options :literal) "<<'EOFpallet'\n" "<<EOFpallet\n")
                   content "\nEOFpallet\n }")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn adjust-file [path options]
  (stevedore/chain-commands*
   (filter
    identity
    [(when (:owner options)
       (stevedore/script (chown ~(options :owner) ~path)))
     (when (:group options)
       (stevedore/script (chgrp ~(options :group) ~path)))
     (when (:mode options)
       (stevedore/script (chmod ~(options :mode) ~path)))])))</pre></tr><tr><td class="docs"><p>Create a .md5 file for the specified input file</p>
</td><td class="codes" /><pre class="brush: clojure">(defn write-md5-for-file
  [path md5-path]
  (stevedore/script
   ((md5sum ~path) > ~md5-path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn touch-file [path opts]
  (stevedore/chain-commands
   (stevedore/script
    (touch ~path ~(select-keys opts [:force])))
   (adjust-file path opts)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource file
  "File management."
  (file*
   [request path & {:keys [action owner group mode force]
                    :or {action :create}
                    :as options}]
   (case action
     :delete (stevedore/checked-script
              (str "delete file " path)
              (rm ~path ~{:force (:force options true)}))
     :create (stevedore/checked-commands
              (str "file " path)
              (touch-file path options))
     :touch (stevedore/checked-commands
             (str "file " path)
             (touch-file path options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource symbolic-link
  "Symbolic link management."
  (symbolic-link*
   [request from name & {:keys [action owner group mode force]
                                        :or {action :create force true}}]
   (case action
     :delete (stevedore/checked-script
              (str "Link %s " name)
              (rm ~name ~{:force force}))
     :create (stevedore/checked-script
              (format "Link %s as %s" from name)
              (ln -s
                  ~(stevedore/map-to-arg-string {:force force})
                  ~from ~name)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource fifo
  "FIFO pipe management."
  (fifo*
   [request path & {:keys [action] :or {action :create} :as options}]
   (case action
     :delete (stevedore/checked-script
              (str "fifo " path)
              (rm ~path ~{:force force}))
     :create (stevedore/checked-commands
              (str "fifo " path)
              (stevedore/script
               (if-not (file-exists? ~path)
                 (mkfifo ~path)))
              (adjust-file path options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource sed
  "Execute sed on a file.  Takes a path and a map for expr to replacement."
  (sed*
   [request path exprs-map & {:keys [seperator no-md5 restriction] :as options}]
   (stevedore/checked-script
    (format "sed file %s" path)
    (sed-file ~path ~exprs-map ~options)
    ~(when-not no-md5
       (write-md5-for-file path (str path ".md5"))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.filesystem" name="pallet.resource.filesystem"><h1 class="project-name">pallet.resource.filesystem</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Filesystem resource</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.filesystem
  (:require
   [pallet.resource.directory :as directory]
   [pallet.resource.exec-script :as exec-script]
   [clojure.string :as string])
  (:use
   pallet.thread-expr))</pre></tr><tr><td class="docs"><p>Format a device as an XFS filesystem.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-xfs-filesytem
  [request device]
  (-> request
      (exec-script/exec-checked-script
       (format "Format %s as XFS" device)
       (mkfs.xfs -f ~device))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti format-mount-option
  (fn [[key value]] (class value)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-mount-option :default
  [[key value]]
  (format "%s=%s" (name key) value))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-mount-option java.lang.Boolean
  [[key value]]
  (when value
    (format "%s" (name key))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- mount-cmd-options [options]
  (let [option-string (string/join ","
                       (filter identity (map format-mount-option options)))]
    (if (string/blank? option-string)
      ""
      (str "-o " option-string))))</pre></tr><tr><td class="docs"><p>Mount a device.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn mount
  [request device mount-point
   & {:keys [device-type automount no-automount dump-frequency boot-check-pass]
      :or {dump-frequency 0 boot-check-pass 0}
      :as options}]
  (->
   request
   (directory/directory mount-point)
   (exec-script/exec-checked-script
    (format "Mount %s at %s" device mount-point)
    (mount ~(mount-cmd-options
             (dissoc options :device-type :dump-frequency :boot-check-pass))
           ~device (quoted ~mount-point)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.filesystem-layout" name="pallet.resource.filesystem-layout"><h1 class="project-name">pallet.resource.filesystem-layout</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Functions to return distribution specific paths.</p>

<p>   These script functions are meant to help build distribution agnostic crates.</p>

<ul>
<li>Links
<ul><li>man 7 hier</li>
<li>http://www.pathname.com/fhs/</li>
<li>http://wiki.apache.org/httpd/DistrosDefaultLayout</li></ul></li>
</ul>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.filesystem-layout
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-default [])
(stevedore/defimpl etc-default [#{:ubuntu :debian :jeos}] []
  "/etc/default")
(stevedore/defimpl etc-default [#{:centos :rhel :amzn-linux :fedora}] []
  "/etc/sysconfig")
(stevedore/defimpl etc-default [#{:os-x :darwin}] []
  "/etc/defaults")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript log-root [])
(stevedore/defimpl log-root :default []
  "/var/log")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pid-root [])
(stevedore/defimpl pid-root :default []
  "/var/run")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript config-root [])
(stevedore/defimpl config-root :default []
  "/etc")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-hosts [])
(stevedore/defimpl etc-hosts :default []
  "/etc/hosts")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript etc-init [])
(stevedore/defimpl etc-init :default []
  "/etc/init.d")</pre></tr><tr><td class="docs"><p>Some of the packagers, like brew, are "add-ons" in the sense that they are
outside of the base system.  These paths refer to locations of packager
installed files.</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-etc-default [])
(stevedore/defimpl pkg-etc-default :default [] (etc-default))
(stevedore/defimpl etc-default [:brew] [] "/usr/local/etc/default")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-log-root [])
(stevedore/defimpl pkg-log-root :default [] (log-root))
(stevedore/defimpl pkg-log-root [:brew] [] "/usr/local/var/log")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-pid-root [])
(stevedore/defimpl pkg-pid-root :default [] (pid-root))
(stevedore/defimpl pkg-pid-root [:brew] [] "/usr/local/var/run")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-config-root [])
(stevedore/defimpl pkg-config-root :default [] (config-root))
(stevedore/defimpl pkg-config-root [:brew] [] "/usr/local/etc")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript pkg-sbin [])
(stevedore/defimpl pkg-sbin :default [] "/sbin")
(stevedore/defimpl pkg-sbin [:brew] [] "/usr/local/sbin")</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.format" name="pallet.resource.format"><h1 class="project-name">pallet.resource.format</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Some standard file formating.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.format
  (:require
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>A sectioned property file.
   This is modeled as vector of maps. The keys of the outer map are the section
   names.  The inner maps are keyword value maps.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn sectioned-properties
  [m]
  (letfn [(format-kv
           [[key-name value]]
           (format "%s = %s\n" (name key-name) value))
          (format-section
           [[section-name kv-map]]
           (format
            "[%s]\n%s\n" (name section-name)
            (string/join (map format-kv kv-map))))]
    (string/join (map format-section m))))</pre></tr><tr><td class="docs"><p>A property file.
   The properties are written "key value", one per line.
     m                   a key-value map
     :seperator chars    seperator to use between key and value
                         (default is a single space)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn name-values
  "A property file.
   The properties are written \"key value\", one per line.
     m                   a key-value map
     :seperator chars    seperator to use between key and value
                         (default is a single space)"
  [m & {:keys [separator] :or {separator " "}}]
  (string/join
   (map
    (fn [[key-name value]] (format "%s%s%s\n" (name key-name) separator value))
    m)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.hostinfo" name="pallet.resource.hostinfo"><h1 class="project-name">pallet.resource.hostinfo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Host information.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.hostinfo
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore])
  (:use
   [pallet.resource :only [defresource]]
   clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript os-version-name [])
(stevedore/defimpl os-version-name [#{:ubuntu :debian}] []
  @(lsb_release -c -s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl os-version-name :default []
  "")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript hostname [& options])
(stevedore/defimpl hostname :default [& options]
  @("hostname"
    ~(if (first options)
       (stevedore/map-to-arg-string (apply hash-map options)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript dnsdomainname [])
(stevedore/defimpl dnsdomainname :default []
  @("dnsdomainname"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript nameservers [])
(stevedore/defimpl nameservers :default []
  @("grep" nameserver "/etc/resolv.conf" | cut "-f2"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript debian-version [])
(stevedore/defimpl debian-version :default []
  (if (file-exists? "/etc/debian") (cat "/etc/debian")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript redhat-version [])
(stevedore/defimpl redhat-version :default []
  (if (file-exists? "/etc/redhat-release") (cat "/etc/redhat-release")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript ubuntu-version [])
(stevedore/defimpl ubuntu-version :default []
  (if (file-exists? "/usr/bin/lsb_release") @("/usr/bin/lsb_release" -c -s)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript arch [])
(stevedore/defimpl architecture :default []
  @(uname -p))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn architecture []
  "Machine CPU architecture."
  (stevedore/script (arch)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.lib" name="pallet.resource.lib"><h1 class="project-name">pallet.resource.lib</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Routines that can be used in other resources</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.lib
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]))</pre></tr><tr><td class="docs"><p>Register changed files</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defscript file-changed [path])
(stevedore/defimpl file-changed :default [path]
  (assoc! changed_files path 1))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript set-flag [path])
(stevedore/defimpl set-flag :default [path]
  (assoc! flags_hash ~(name path) 1))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript flag? [path])
(stevedore/defimpl flag? :default [path]
  (get flags_hash ~(name path)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.network-service" name="pallet.resource.network-service"><h1 class="project-name">pallet.resource.network-service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Resource for working with network services</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.network-service
  (:require
   [pallet.resource.exec-script :as exec-script]))</pre></tr><tr><td class="docs"><p>Wait for the network port <code>port</code> to be in a listening state.</p>

<p>   Options:
   - :standoff      time between checking port state (seconds)
   - :max-retries   number of times to test port state before erroring
   - :service-name  name of service to use in messages (defaults to port)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-port-listen
  [request port & {:keys [max-retries standoff service-name]
                   :or {max-retries 5 standoff 2
                        service-name (str "port " port)}}]
  (->
   request
   (exec-script/exec-checked-script
    (format "Wait for %s to be in a listen state" service-name)
    (group (chain-or (let x 0) true))
    (while
        (pipe (netstat -lnt) (awk ~(format "'$4 ~ /:%s$/ {exit 1}'" port)))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format "Timed out waiting for listen state for %s" service-name)
           >&2)
          (exit 1)))
      (println ~(format "Waiting for %s to be in a listen state" service-name))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="docs"><p>Wait for a url to respond with the given HTTP status code.</p>

<p>   Options:
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :url-name      name of url to use in messages (defaults to url)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-http-status
  [request url status & {:keys [max-retries standoff url-name]
                         :or {max-retries 5 standoff 2
                              url-name url}}]
  (->
   request
   (exec-script/exec-checked-script
    (format "Wait for %s to return a %s status" url-name status)
    (if ("test" @(shell/which wget))
      (defn httpresponse []
        (pipe
         ("wget" -q -S -O "/dev/null" (quoted ~url) "2>&1")
         ("grep" "HTTP/1.1")
         ("tail" -1)
         ("grep" -o -e (quoted "[0-9][0-9][0-9]"))))
      (if ("test" @(shell/which curl))
        (defn httpresponse []
          ("curl" -sL -w (quoted "%{http_code}") (quoted ~url)
           -o "/dev/null"))
        (do
          (println "No httpresponse utility available")
          (shell/exit 1))))
    (group (chain-or (let x 0) true))
    (while
        (!= ~status @(httpresponse))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format
             "Timed out waiting for %s to return a %s status" url-name status)
           >&2)
          (exit 1)))
      (println ~(format "Waiting for %s to return a %s status" url-name status))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="docs"><p>Wait for a port to respond to a message with a given response regex.</p>

<p>   Options:
   - :host          host to check (defaults to localhost)
   - :timeout       time to wait for a response (default 2 secs)
   - :standoff      time between checking HTTP status (seconds)
   - :max-retries   number of times to test HTTP status before erroring
   - :service-name  name of service to use in messages (defaults to port)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn wait-for-port-response
  [request port message response-regex
   & {:keys [host timeout max-retries standoff service-name]
      :or {host "localhost" max-retries 5 standoff 2 timeout 2
           service-name (str "port " port)}}]
  (->
   request
   (exec-script/exec-checked-script
    (format
     "Wait for %s to return a response %s to message %s"
     service-name response-regex message)
    (group (chain-or (let x 0) true))
    (while
        (! (pipe (println (quoted ~message))
                 ("nc" -q ~timeout ~host ~port)
                 ("grep" -E (quoted ~response-regex))))
      (let x (+ x 1))
      (if (= ~max-retries @x)
        (do
          (println
           ~(format
             "Timed out waiting for %s to return response %s"
             service-name response-regex)
           >&2)
          (exit 1)))
      (println
       ~(format
         "Waiting for %s to return response %s" service-name response-regex))
      (sleep ~standoff))
    (sleep ~standoff))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.package" name="pallet.resource.package"><h1 class="project-name">pallet.resource.package</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Package management resource.</p>

<p>   <code>package</code> is used to install or remove a package.</p>

<p>   <code>package-source</code> is used to specify a non-standard source for packages.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.package
  (:require
   [pallet.resource :as resource]
   [pallet.resource.file :as file]
   [pallet.resource.remote-file :as remote-file]
   [pallet.resource.hostinfo :as hostinfo]
   [pallet.resource.exec-script :as exec-script]
   [pallet.stevedore :as stevedore]
   [pallet.request-map :as request-map]
   [pallet.script :as script]
   [pallet.utils :as utils]
   [pallet.target :as target]
   [clojure.contrib.string :as string]
   [clojure.contrib.logging :as logging])
  (:use
   [pallet.resource :only [defaggregate defresource]]
   [clojure.contrib.core :only [-?>]]
   pallet.thread-expr))</pre></tr><tr><td class="docs"><p>the package management commands vary for each distribution, so we
use a script multimethod to describe these</p>
</td><td class="codes" /><pre class="brush: clojure">(script/defscript update-package-list
  "Update the list of packages available to the package manager from the
   declared package sources."
  [& options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript upgrade-all-packages
  "Upgrade the all installed package."
  [& options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript install-package
  "Install the specified package."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript upgrade-package
  "Upgrade the specified package."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript remove-package
  "Uninstall the specified package, leaving the configuration files if
   possible."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript purge-package
  "Uninstall the specified package, removing the configuration files if
   possible."
  [name & options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript list-installed-packages
  "List the installed packages"
  [& options])</pre></tr><tr><td class="docs"><p>Implementation to do nothing
Repeating the selector makes it more explicit</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:no-packages} #{:no-packages}]
  [& options] "")
(stevedore/defimpl upgrade-all-packages [#{:no-packages} #{:no-packages}]
  [& options] "")
(stevedore/defimpl install-package [#{:no-packages} #{:no-packages}]
  [package & options] "")
(stevedore/defimpl upgrade-package [#{:no-packages} #{:no-packages}]
  [package & options] "")
(stevedore/defimpl remove-package [#{:no-packages} #{:no-packages}]
  [package & options] "")
(stevedore/defimpl purge-package [#{:no-packages} #{:no-packages}]
  [package & options] "")
(stevedore/defimpl list-installed-packages [#{:no-packages} #{:no-packages}]
  [& options] "")</pre></tr><tr><td class="docs"><p>aptitude</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:aptitude}] [& options]
  (chain-or
   (aptitude update ~(stevedore/option-args options)) true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-all-packages [#{:aptitude}] [& options]
  (aptitude upgrade -q -y ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl install-package [#{:aptitude}] [package & options]
  (aptitude install -q -y ~(stevedore/option-args options) ~package
            ;; show returns an error code if no package found, while install
            ;; does not.  There should be a better way than this...
            "&&" aptitude show ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-package [#{:aptitude}] [package & options]
  (aptitude install -q -y ~(stevedore/option-args options) ~package
            ;; show returns an error code if no package found, while install
            ;; does not.  There should be a better way than this...
            "&&" aptitude show ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl remove-package [#{:aptitude}] [package & options]
  (aptitude remove -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl purge-package [#{:aptitude}] [package & options]
  (aptitude purge -y  ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl list-installed-packages [#{:aptitude}] [& options]
  (aptitude search (quoted "~i")))</pre></tr><tr><td class="docs"><p>yum</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:yum}] [& options]
  (yum makecache -q ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-all-packages [#{:yum}] [& options]
  (yum update -y -q ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl install-package [#{:yum}] [package & options]
  (yum install -y -q ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-package [#{:yum}] [package & options]
  (yum upgrade -y -q ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl remove-package [#{:yum}] [package & options]
  (yum remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl purge-package [#{:yum}] [package & options]
  (yum purge ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl list-installed-packages [#{:yum}] [& options]
  (yum list installed))</pre></tr><tr><td class="docs"><p>zypper</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:zypper}] [& options]
  (zypper refresh ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-all-packages [#{:zypper}] [& options]
  (zypper update -y ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl install-package [#{:zypper}] [package & options]
  (zypper install -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl remove-package [#{:zypper}] [package & options]
  (zypper remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl purge-package [#{:zypper}] [package & options]
  (zypper remove ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs"><p>pacman</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:pacman}] [& options]
  (pacman -Sy "--noconfirm" "--noprogressbar" ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-all-packages [#{:pacman}] [& options]
  (pacman -Su "--noconfirm" "--noprogressbar" ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl install-package [#{:pacman}] [package & options]
  (pacman -S "--noconfirm" "--noprogressbar"
          ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-package [#{:pacman}] [package & options]
  (pacman -S "--noconfirm" "--noprogressbar"
          ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl remove-package [#{:pacman}] [package & options]
  (pacman -R "--noconfirm" ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl purge-package [#{:pacman}] [package & options]
  (pacman -R "--noconfirm" "--nosave"
          ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs"><p>brew</p>
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl update-package-list [#{:brew}] [& options]
  (brew update ~(stevedore/option-args options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl upgrade-all-packages [#{:brew}] [& options]
  (comment "No command to do this"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl install-package [#{:brew}] [package & options]
  (brew install -y ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl remove-package [#{:brew}] [package & options]
  (brew uninstall ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl purge-package [#{:brew}] [package & options]
  (brew uninstall ~(stevedore/option-args options) ~package))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript debconf-set-selections [& selections])
(stevedore/defimpl debconf-set-selections :default [& selections] "")
(stevedore/defimpl debconf-set-selections [#{:aptitude}] [& selections]
  ("{ debconf-set-selections"
   ~(str "<<EOF\n" (string/join \newline selections) "\nEOF\n}")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript package-manager-non-interactive [])
(stevedore/defimpl package-manager-non-interactive :default [] "")
(stevedore/defimpl package-manager-non-interactive [#{:aptitude}] []
  (debconf-set-selections
   "debconf debconf/frontend select noninteractive"
   "debconf debconf/frontend seen false"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmulti adjust-packages
  (fn [request & _]
    (:target-packager request)))</pre></tr><tr><td class="docs"><p>aptitude can install, remove and purge all in one command, so we just need to
split by enable/disable options.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :aptitude
  [request packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/script (package-manager-non-interactive))
   (stevedore/chain-commands*
    (for [[opts packages] (->>
                           packages
                           (group-by #(select-keys % [:enable]))
                           (sort-by #(apply min (map :priority (second %)))))]
      (stevedore/script
       (aptitude
        install -q -y
        ~(string/join " " (map #(str "-t " %) (:enable opts)))
        ~(string/join
          " "
          (for [[action packages] (group-by :action packages)
                {:keys [package force purge]} packages]
            (case action
              :install (format "%s+" package)
              :remove (if purge
                        (format "%s_" package)
                        (format "%s-" package))
              :upgrade (format "%s+" package)
              (throw
               (IllegalArgumentException.
                (str
                 action " is not a valid action for package resource"))))))))))
   (stevedore/script (list-installed-packages))))</pre></tr><tr><td class="docs"><p>Define the order of actions</p>
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true :doc }
  action-order {:install 10 :remove 20 :upgrade 30})</pre></tr><tr><td class="docs"><p><code>yum</code> has separate install, remove and purge commands, so we just need to
split by enable/disable options and by command.  We install before removing.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :yum
  [request packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/chain-commands*
    (conj
     (vec
      (for [[action packages] (->> packages
                                   (sort-by #(action-order (:action %)))
                                   (group-by :action))
            [opts packages] (->>
                             packages
                             (group-by #(select-keys % [:enable :disable]))
                             (sort-by #(apply min (map :priority (second %)))))]
        (stevedore/script
         (yum
          ~(name action) -q -y
          ~(string/join " " (map #(str "--enablerepo=" %) (:enable opts)))
          ~(string/join " " (map #(str "--disablerepo=" %) (:disable opts)))
          ~(string/join
            " "
            (distinct (map :package packages)))))))
     (stevedore/script (list-installed-packages))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod adjust-packages :default
  [request packages]
  (stevedore/checked-commands
   "Packages"
   (stevedore/chain-commands*
    (list*
     (stevedore/script (package-manager-non-interactive))
     (for [[action packages] (group-by :action packages)
           {:keys [package force purge]} packages]
       (case action
         :install (stevedore/script
                   (install-package ~package :force ~force))
         :remove (if purge
                   (stevedore/script (purge-package ~package))
                   (stevedore/script (remove-package ~package)))
         :upgrade (stevedore/script (upgrade-package ~package))
         (throw
          (IllegalArgumentException.
           (str action " is not a valid action for package resource")))))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- package-map
  "Convert the args into a single map"
  [request package-name
   & {:keys [action y force purge priority enable disable] :as options}]
  (letfn [(as-seq [x] (if (or (string? x) (symbol? x) (keyword? x))
                        [(name x)] x))]
    (->
     {:action :install :y true :priority 50}
     (merge options)
     (assoc :package package-name)
     (update-in [:enable] as-seq)
     (update-in [:disable] as-seq))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defaggregate package
  "Install or remove a package.

   Options
    - :action [:install | :remove | :upgrade]
    - :purge [true|false]         when removing, whether to remove all config
    - :enable [repo|(seq repo)]   enable specific repository
    - :disable [repo|(seq repo)]  disable specific repository
    - :priority n                 priority (0-100, default 50)

   Package management occurs in one shot, so that the package manager can
   maintain a consistent view."
  {:use-arglist  [request package-name
                  & {:keys [action y force purge enable disable priority]
                     :or {action :install
                          y true
                          priority 50}
                     :as options}]}
  (package*
   [request args]
   (adjust-packages request (map #(apply package-map request %) args))))</pre></tr><tr><td class="docs"><p>Install a list of packages keyed on packager.
       (packages request
         :yum ["git" "git-email"]
         :aptitude ["git-core" "git-email"])</p>
</td><td class="codes" /><pre class="brush: clojure">(defn packages
  "Install a list of packages keyed on packager.
       (packages request
         :yum [\"git\" \"git-email\"]
         :aptitude [\"git-core\" \"git-email\"])"
  [request & {:keys [yum aptitude pacman brew] :as options}]
  (->
   request
   (for->
    [package-name (options (:target-packager request))]
    (package package-name))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def source-location
  {:aptitude "/etc/apt/sources.list.d/%s.list"
   :yum "/etc/yum.repos.d/%s.repo"})</pre></tr><tr><td class="docs"><p>Format a package source definition</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti format-source
  (fn [packager & _] packager))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-source :aptitude
  [_ name options]
  (format
   "%s %s %s %s\n"
   (:source-type options "deb")
   (:url options)
   (:release options (stevedore/script (os-version-name)))
   (string/join " " (:scopes options ["main"]))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod format-source :yum
  [_ name {:keys [url mirrorlist gpgcheck gpgkey priority failovermethod
                  enabled]
           :or {enabled 1}
           :as options}]
  (string/join
   "\n"
   (filter
    identity
    [(format "[%s]\nname=%s" name name)
     (when url (format "baseurl=%s" url))
     (when mirrorlist (format "mirrorlist=%s" mirrorlist))
     (format "gpgcheck=%s" (or (and gpgkey 1) 0))
     (when gpgkey (format "gpgkey=%s" gpgkey))
     (when priority (format "priority=%s" priority))
     (when failovermethod (format "failovermethod=%s" failovermethod))
     (format "enabled=%s" enabled)
     ])))</pre></tr><tr><td class="docs"><p>Add a packager source.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn package-source*
  [request name & {:as options}]
  (let [packager (request-map/packager request)]
    (stevedore/checked-commands
     "Package source"
     (let [key-url (-> options :aptitude :url)]
       (if (and key-url (.startsWith key-url "ppa:"))
         (stevedore/chain-commands
          (stevedore/script (install-package "python-software-properties"))
          (stevedore/script (add-apt-repository ~key-url)))
         (remote-file/remote-file*
          request
          (format (source-location packager) name)
          :content (format-source packager name (packager options))
          :literal (= packager :yum))))
     (if (and (-> options :aptitude :key-id)
              (= packager :aptitude))
       (stevedore/script
        (apt-key adv
                 "--keyserver subkeys.pgp.net --recv-keys"
                 ~(-> options :aptitude :key-id))))
     (if (and (-> options :aptitude :key-url)
              (= packager :aptitude))
       (stevedore/chain-commands
        (remote-file/remote-file*
         request
         "aptkey.tmp"
         :url (-> options :aptitude :key-url))
        (stevedore/script (apt-key add aptkey.tmp))))
     (when-let [key (and (= packager :yum) (-> options :yum :gpgkey))]
       (stevedore/script (rpm "--import" ~key))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(declare package-manager)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defaggregate ^{:always-before #{`package-manager `package}} package-source
  "Control package sources.
   Options are the package manager keywords, each specifying a map of
   packager specific options.

   :aptitude
     - :source-type string   - source type (deb)
     - :url url              - repository url
     - :scopes seq           - scopes to enable for repository
     - :key-url url          - url for key
     - :key-id id            - id for key to look it up from keyserver

   :yum
     - :name                 - repository name
     - :url url          - repository base url
     - :gpgkey url           - gpg key url for repository

   Example
       (package-source \"Partner\"
         :aptitude {:url \"http://archive.canonical.com/\"
                    :scopes [\"partner\"]})"
  {:copy-arglist pallet.resource.package/package-source*}
  (package-source-aggregate
   [request args]
   (stevedore/do-script*
    (map (fn [x] (apply package-source* request x)) args))))</pre></tr><tr><td class="docs"><p>Add a scope to all the existing package sources. Aptitude specific.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-scope*
  [type scope file]
  (stevedore/chained-script
   (var tmpfile @(mktemp -t addscopeXXXX))
   (cp -p ~file @tmpfile)
   (awk "'{if ($1 ~" ~(str "/^" type "/") "&& !" ~(str "/" scope "/")
        " ) print $0 \" \" \"" ~scope  "\" ; else print; }'"
        ~file > @tmpfile)
   (mv -f @tmpfile ~file)))</pre></tr><tr><td class="docs"><p>Add a scope to an apt source</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-scope
  [opts]
  (add-scope*
   (or (opts :type) "deb.*")
   (:scope opts)
   (or (opts :file) "/etc/apt/sources.list")))</pre></tr><tr><td class="docs"><p>Configure the package manager</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti configure-package-manager
  (fn [request packager options] packager))</pre></tr><tr><td class="docs"><p>Provide packager specific options</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti package-manager-option
  (fn [request packager option value] [packager option]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:aptitude :proxy]
  [request packager proxy proxy-url]
  (format "ACQUIRE::http::proxy \"%s\";" proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:yum :proxy]
  [request packager proxy proxy-url]
  (format "proxy=%s" proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod package-manager-option [:pacman :proxy]
  [request packager proxy proxy-url]
  (format
   (str "XferCommand = /usr/bin/wget "
        "-e \"http_proxy = %s\" -e \"ftp_proxy = %s\" "
        "--passive-ftp --no-verbose -c -O %%o %%u")
   proxy-url proxy-url))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :aptitude
  [request packager {:keys [priority prox] :or {priority 50} :as options}]
  (remote-file/remote-file*
   request
   (format "/etc/apt/apt.conf.d/%spallet" priority)
   :content (string/join
             \newline
             (map
              #(package-manager-option request packager (key %) (val %))
              (dissoc options :priority)))
   :literal true))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :yum
  [request packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (remote-file/remote-file*
    request
    "/etc/yum.pallet.conf"
    :content (string/join
              \newline
              (map
               #(package-manager-option request packager (key %) (val %))
               (dissoc options :priority)))
    :literal true)
   ;; include yum.pallet.conf from yum.conf
   (stevedore/script
    (if (not @("fgrep" "yum.pallet.conf" "/etc/yum.conf"))
      (do
        ("cat" ">>" "/etc/yum.conf" " <<'EOFpallet'")
        "include=file:///etc/yum.pallet.conf"
        "EOFpallet")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :pacman
  [request packager {:keys [proxy] :as options}]
  (stevedore/chain-commands
   (remote-file/remote-file*
    request
    "/etc/pacman.pallet.conf"
    :content (string/join
              \newline
              (map
               #(package-manager-option request packager (key %) (val %))
               (dissoc options :priority)))
    :literal true)
   ;; include pacman.pallet.conf from pacman.conf
   (stevedore/script
    (if (not @("fgrep" "pacman.pallet.conf" "/etc/pacman.conf"))
      (do
        ~(file/sed*
          request
          "/etc/pacman.conf"
          "a Include = /etc/pacman.pallet.conf"
          :restriction "/\\[options\\]/"))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod configure-package-manager :default
  [request packager {:as options}]
  (comment "do nothing"))</pre></tr><tr><td class="docs"><p>Package management.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn package-manager*
  [request action & options]
  (let [packager (:target-packager request)]
    (stevedore/checked-commands
     "package-manager"
     (case action
       :update (stevedore/script (update-package-list))
       :upgrade (stevedore/script (upgrade-all-packages))
       :list-installed (stevedore/script (list-installed-packages))
       :add-scope (add-scope (apply hash-map options))
       :multiverse (add-scope (apply hash-map :scope "multiverse" options))
       :universe (add-scope (apply hash-map :scope "universe" options))
       :debconf (if (= :aptitude packager)
                  (stevedore/script (apply debconf-set-selections ~options)))
       :configure (configure-package-manager request packager options)
       (throw (IllegalArgumentException.
               (str action
                    " is not a valid action for package-manager resource")))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defaggregate ^{:always-before `package} package-manager
  "Package manager controls.

   `action` is one of the following:
   - :update          - update the list of available packages
   - :list-installed  - output a list of the installed packages
   - :add-scope       - enable a scope (eg. multiverse, non-free)

   To refresh the list of packages known to the pakage manager:
       (package-manager request :update)

   To enable multiverse on ubuntu:
       (package-manager request :add-scope :scope :multiverse)

   To enable non-free on debian:
       (package-manager request :add-scope :scope :non-free)"
  {:copy-arglist pallet.resource.package/package-manager*}
  (apply-package-manager
   [request package-manager-args]
   (stevedore/do-script*
    (map #(apply package-manager* request %) (distinct package-manager-args)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} centos-55-repo
  "http://mirror.centos.org/centos/5.5/os/x86_64/repodata/repomd.xml")
(def ^{:private true} centos-55-repo-key
  "http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-5")</pre></tr><tr><td class="docs"><p>Add the centos 5.5 repository to Amazon Linux. Ensure that it has a lower
   than default priority.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-centos55-to-amzn-linux
  [request]
  (-> request
      (package "yum-priorities")
      (package-source
       "Centos-5.5"
       :yum {:url centos-55-repo
             :gpgkey centos-55-repo-key
             :priority 50})))</pre></tr><tr><td class="docs"><p>Add debian backport source</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-debian-backports
  [request]
  (package-source
   request
   "debian-backports"
   :aptitude {:url "http://backports.debian.org/debian-backports"
              :release (str (stevedore/script (os-version-name)) "-backports")
              :scopes ["main"]}))</pre></tr><tr><td class="docs"><p>this is an aggregate so that it can come before the aggragate package-manager</p>
</td><td class="codes" /><pre class="brush: clojure">(defaggregate ^{:always-before #{`package-manager `package}} add-epel
  "Add the EPEL repository"
  {:use-arglist [request & {:keys [version] :or {version "5-4"}}]}
  (add-epel*
   [request args]
   (let [{:keys [version] :or {version "5-4"}} (apply
                                                merge {}
                                                (map #(apply hash-map %) args))]
     (stevedore/script
      ;; "Add EPEL package repository"
      (rpm
       -U --quiet
       ~(format
         "http://download.fedora.redhat.com/pub/epel/5/%s/epel-release-%s.noarch.rpm"
         "$(uname -i)"
         version))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true}
  rpmforge-url-pattern
  "http://packages.sw.be/rpmforge-release/rpmforge-release-%s.%s.rf.%s.rpm")</pre></tr><tr><td class="docs"><p>this is an aggregate so that it can come before the aggragate package-manager</p>
</td><td class="codes" /><pre class="brush: clojure">(defaggregate ^{:always-before #{`package-manager `package}} add-rpmforge
  "Add the rpmforge repository"
  {:use-arglist [request & {:keys [version distro arch]
                            :or {version "0.5.2-2" distro "el5" arch "i386"}}]}
  (add-rpmforge*
   [request args]
   (let [{:keys [version distro arch]
          :or {version "0.5.2-2"
               distro "el5"
               arch "i386"}} (apply hash-map (first args))]
     (stevedore/checked-script
      "Add rpmforge repositories"
      (chain-or
       (if (= "0" @(pipe (rpm -qa) (grep rpmforge) (wc -l)))
         (do
           ~(remote-file/remote-file*
             request
             "rpmforge.rpm"
             :url (format rpmforge-url-pattern version distro arch))
           (rpm -U --quiet "rpmforge.rpm"))))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def jpackage-mirror-fmt
  "http://www.jpackage.org/mirrorlist.php?dist=%s&type=free&release=%s")</pre></tr><tr><td class="docs"><p>Add the jpackage repository.  component should be one of:
     fedora
     redhat-el</p>

<p>   Installs the jpackage-utils package from the base repos at a
   pritority of 25.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn add-jpackage
  [request & {:keys [version component releasever]
              :or {component "redhat-el"
                   releasever "$releasever"
                   version "5.0"}}]
  (->
   request
   (package-source
    "jpackage-generic"
    :yum {:mirrorlist (format jpackage-mirror-fmt "generic" version)
          :failovermethod "priority"
          ;;gpgkey "http://www.jpackage.org/jpackage.asc"
          :enabled 1})
   (package-source
    (format "jpackage-%s" component)
    :yum {:mirrorlist (format
                       jpackage-mirror-fmt
                       (str component "-" releasever) version)
          :failovermethod "priority"
          ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
          :enabled 1})
   (package-source
    "jpackage-generic-updates"
    :yum {:mirrorlist (format
                       jpackage-mirror-fmt "generic" (str version "-updates"))
          :failovermethod "priority"
          ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
          :enabled 1})
   (package-source
    (format "jpackage-%s-updates" component)
    :yum {:mirrorlist (format
                       jpackage-mirror-fmt
                       (str component "-" releasever) (str version "-updates"))
          :failovermethod "priority"
          ;;:gpgkey "http://www.jpackage.org/jpackage.asc"
          :enabled 1})
   (package
    "jpackage-utils"
    :priority 25
    :disable ["jpackage-generic"
              "jpackage-generic-updates"
              (format "jpackage-%s" component)
              (format "jpackage-%s-updates" component)])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defaggregate
  ^{:always-before `package-manager `package-source `package}
  minimal-packages
  "Add minimal packages for pallet to function"
  {:use-arglist [request]}
  (minimal-packages*
   [request args]
   (let [os-family (request-map/os-family request)]
     (cond
      (#{:ubuntu :debian} os-family) (stevedore/checked-script
                                      "Add minimal packages"
                                      (update-package-list)
                                      (install-package "coreutils")
                                      (install-package "sudo"))
      (= :arch os-family) (stevedore/checked-script
                           "Add minimal packages"
                           (update-package-list)
                           (install-package "sudo"))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.remote-directory" name="pallet.resource.remote-directory"><h1 class="project-name">pallet.resource.remote-directory</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Resource to specify the content of a remote directory.  At present the
   content can come from a downloaded tar or zip file.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.remote-directory
  (:require
   [pallet.resource :as resource]
   [pallet.stevedore :as stevedore]
   [pallet.resource.directory :as directory]
   [pallet.resource.remote-file :as remote-file]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(resource/defresource remote-directory
  "Specify the contents of remote directory.

   Options:
    - :url              - a url to download content from
    - :unpack           - how download should be extracts (default :tar)
    - :tar-options      - options to pass to tar (default \"xz\")
    - :unzip-options    - options to pass to unzip (default \"-o\")
    - :strip-components - number of path compnents to remove when unpacking
    - :md5              - md5 of file to unpack
    - :md5-url          - url of md5 file for file to unpack

   Ownership options:
    - :owner            - owner of files
    - :group            - group of files
    - :recursive        - flag to recursively set owner and group

   To install the content of an url pointing at a tar file, specify the :url
   option.
       (remote-directory request path
          :url \"http://a.com/path/file.tgz\")

   If there is an md5 url with the tar file's md5, you can specify that as well,
   to prevent unecessary downloads and verify the content.
       (remote-directory request path
          :url \"http://a.com/path/file.tgz\"
          :md5-url \"http://a.com/path/file.md5\")

   To install the content of an url pointing at a zip file, specify the :url
   option and :unpack :unzip.
       (remote-directory request path
          :url \"http://a.com/path/file.\"
          :unpack :unzip)"
  (remote-directory*
   [request path & {:keys [action url unpack tar-options unzip-options
                           strip-components md5 md5-url owner group recursive]
                    :or {action :create
                         tar-options "xz"
                         unzip-options "-o"
                         strip-components 1}
                    :as options}]

   (case action
     :create (let [url (options :url)
                   unpack (options :unpack :tar)]
               (when (and url unpack)
                 (let [filename (.getName
                                 (java.io.File. (.getFile (java.net.URL. url))))
                       tarpath (str (stevedore/script (tmp-dir)) "/" filename)]
                   (stevedore/checked-commands
                    "remote-directory"
                    (directory/directory*
                     request path :owner owner :group group)
                    (remote-file/remote-file*
                     request tarpath :url url :md5 md5 :md5-url md5-url)
                    (condp = unpack
                        :tar (stevedore/script
                              (cd ~path)
                              (tar ~tar-options
                                   ~(str "--strip-components=" strip-components)
                                   -f ~tarpath))
                        :unzip (stevedore/script
                                (cd ~path)
                                (unzip ~unzip-options ~tarpath)))
                    (if recursive
                      (directory/directory*
                       request path
                       :owner owner
                       :group group
                       :recursive recursive)))))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.remote-file" name="pallet.resource.remote-file"><h1 class="project-name">pallet.resource.remote-file</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Resource to specify remote file content.</p>

<p>   <code>remote-file</code> has many options for the content of remote files.  Ownership
   and mode can of course be specified. By default the remote file is versioned,
   and multiple versions are kept.</p>

<p>   Modification of remote files outside of pallet cause an error to be raised
   by default.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.remote-file
  (:require
   [pallet.blobstore :as blobstore]
   [pallet.resource :as resource]
   [pallet.resource.directory :as directory]
   [pallet.resource.file :as file]
   [pallet.resource.lib :as lib]
   [pallet.stevedore :as stevedore]
   [pallet.template :as templates]
   [pallet.utils :as utils]
   [clojure.contrib.def :as def]
   [clojure.java.io :as io])
  (:use pallet.thread-expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def install-new-files true)
(def force-overwrite false)</pre></tr><tr><td class="docs"><p>Set boolean flag to control installation of new files</p>
</td><td class="codes" /><pre class="brush: clojure">(defn set-install-new-files
  [flag]
  (alter-var-root #'install-new-files (fn [_] flag)))</pre></tr><tr><td class="docs"><p>Globally force installation of new files, even if content on node has
  changed.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn set-force-overwrite
  [flag]
  (alter-var-root #'force-overwrite (fn [_] flag)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  content-options
  [:local-file :remote-file :url :md5 :content :literal :template :values
   :action :blob :blobstore]
  "A vector of the options accepted by remote-file.  Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  version-options
  [:overwrite-changes :no-versioning :max-versions :flag-on-changed]
  "A vector of options for controlling versions. Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  ownership-options
  [:owner :group :mode]
  "A vector of options for controlling ownership. Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defvar
  all-options
  (concat content-options version-options ownership-options)
  "A vector of the options accepted by remote-file.  Can be used for option
  forwarding when calling remote-file from other crates.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- get-request
  "Build a curl or wget command from the specified request object."
  [request]
  (stevedore/script
   (if (test @(which curl))
     (curl -s "--retry" 20
           ~(apply str (map
                        #(format "-H \"%s: %s\" " (first %) (second %))
                        (.. request getHeaders entries)))
           ~(.. request getEndpoint toASCIIString))
     (if (test @(which wget))
       (wget -nv "--tries" 20
             ~(apply str (map
                          #(format "--header \"%s: %s\" " (first %) (second %))
                          (.. request getHeaders entries)))
             ~(.. request getEndpoint toASCIIString))
       (do
         (println "No download utility available")
         (exit 1))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- arg-vector
  "Return the non-request arguments."
  [_ & args]
  args)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- delete-local-path
  [request local-path]
  (.delete local-path)
  request)</pre></tr><tr><td class="docs"><p>Function to call f with a local copy of the requested remote path.
   f should be a function taking [request local-path &amp; _], where local-path will
   be a File with a copy of the remote file (which will be unlinked after
   calling f.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn with-remote-file
  [request f path & args]
  (let [local-path (utils/tmpfile)]
    (->
     request
     (resource/invoke-resource #'arg-vector [path (.getPath local-path)]
                               :in-sequence :transfer/to-local)
     (apply-> f local-path args)
     (resource/invoke-resource
      #'delete-local-path [local-path]
      :in-sequence :fn/clojure))))</pre></tr><tr><td class="docs"><p>Function to transfer a local file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn transfer-file
  [request local-path remote-path]
  (resource/invoke-resource
   request #'arg-vector [local-path remote-path]
   :in-sequence :transfer/from-local))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(resource/defresource remote-file-resource
  (remote-file*
   [request path & {:keys [action url local-file remote-file link
                           content literal
                           template values
                           md5 md5-url
                           owner group mode force
                           blob blobstore
                           overwrite-changes no-versioning max-versions
                           flag-on-changed]
                    :or {action :create max-versions 5}
                    :as options}]
   (let [new-path (str path ".new")
         md5-path (str path ".md5")
         versioning (if no-versioning "" (stevedore/script (backup-option)))]
     (case action
       :create
       (stevedore/checked-commands
        (str "remote-file " path)
        (cond
         (and url md5) (stevedore/chained-script
                        (if (|| (not (file-exists? ~path))
                                (!= ~md5 @((pipe
                                            (md5sum ~path)
                                            (cut "-f1" "-d" "' '")))))
                          ~(stevedore/chained-script
                            (download-file ~url ~new-path))))
         ;; Download md5 to temporary directory.
         (and url md5-url) (stevedore/chained-script
                            (var tmpdir (quoted (make-temp-dir "rf")))
                            (var basefile
                                 (quoted (str @tmpdir "/" @(basename ~path))))
                            (var newmd5path (quoted (str @basefile ".md5")))
                            (download-file ~md5-url @newmd5path)
                            (if (|| (not (file-exists? ~md5-path))
                                    (diff @newmd5path ~md5-path))
                              (do
                                (download-file ~url ~new-path)
                                (ln -s ~new-path @basefile)
                                (if-not (md5sum-verify @newmd5path)
                                  (do
                                    (echo ~(str "Download of " url
                                                " failed to match md5"))
                                    (exit 1)))))
                            (rm @tmpdir ~{:force true :recursive true}))
         url (stevedore/chained-script
              (download-file ~url ~new-path))
         content (apply file/heredoc
                        new-path content
                        (apply concat (seq (select-keys options [:literal]))))
         local-file nil
                   ;; (let [temp-path (resource/register-file-transfer!
                   ;;                   local-file)]
                   ;;    (stevedore/script
                   ;;     (mv -f (str "~/" ~temp-path) ~new-path)))
         remote-file (stevedore/script
                      (cp -f ~remote-file ~new-path))
         template (apply
                   file/heredoc
                   new-path
                   (templates/interpolate-template
                    template (or values {}) (:node-type request))
                   (apply concat (seq (select-keys options [:literal]))))
         link (stevedore/script (ln -f -s ~link ~path))
         blob (stevedore/checked-script
               "Download blob"
               (download-request
                ~new-path
                ~(blobstore/sign-blob-request
                  (or blobstore (:blobstore request)
                      (throw (IllegalArgumentException.
                              "No :blobstore given for blob content.") ))
                  (:container blob) (:path blob)
                  {:method :get})))
         :else (throw
                (IllegalArgumentException.
                 (str "remote-file " path " specified without content."))))

        ;; process the new file accordingly
        (when install-new-files
          (stevedore/chain-commands
           (if (or overwrite-changes no-versioning force-overwrite)
             (stevedore/script
              (if (file-exists? ~new-path)
                (do
                  ~(stevedore/chain-commands
                    (stevedore/script (mv -f ~versioning ~new-path ~path))
                    (if flag-on-changed
                      (stevedore/script (set-flag ~flag-on-changed)))))))
             (stevedore/script
              (var md5diff "")
              (if (&& (file-exists? ~path) (file-exists? ~md5-path))
                (do
                  (md5sum-verify ~md5-path)
                  (set! md5diff "$?")))
              (var contentdiff "")
              (if (&& (file-exists? ~path) (file-exists? ~new-path))
                (do
                  (diff -u ~path ~new-path)
                  (set! contentdiff "$?")))
              (if (== @md5diff 1)
                (do
                  (echo "Existing content did not match md5:")
                  (exit 1)))
              (if (!= @contentdiff "0")
                (do
                  ~(stevedore/chain-commands
                    (stevedore/script (mv -f ~versioning ~new-path ~path))
                    (if flag-on-changed
                      (stevedore/script (set-flag ~flag-on-changed))))))
              (if-not (file-exists? ~path)
                (do
                  ~(stevedore/chain-commands
                    (stevedore/script (mv ~new-path ~path))
                    (if flag-on-changed
                      (stevedore/script (set-flag ~flag-on-changed))))))))
           (file/adjust-file path options)
           (when-not no-versioning
             (stevedore/chain-commands
              (file/write-md5-for-file path md5-path)
              (stevedore/script (echo "MD5 sum is" @(cat ~md5-path)))))))
        ;; cleanup
        (if (and (not no-versioning) (pos? max-versions))
          (stevedore/script
           (pipe
            (ls -t (str ~path ".~[0-9]*~") "2>" "/dev/null")
            (tail -n ~(str "+" (inc max-versions)))
            (xargs rm -f)))))
       :delete (stevedore/checked-script
                (str "delete remote-file " path)
                (rm ~path ~(select-keys options [:force])))))))</pre></tr><tr><td class="docs"><p>Remote file content management.</p>

<p>The <code>remote-file</code> resource can specify the content of a remote file in a number
different ways.</p>

<p>By default, the remote-file is versioned, and 5 versions are kept.</p>

<p>The remote content is also verified against it's md5 hash.  If the contents
of the remote file have changed (e.g. have been edited on the remote machine)
then by default the file will not be overwritten, and an error will be raised.
To force overwrite, call <code>set-force-overwrite</code> before running <code>converge</code> or
<code>lift</code>.</p>

<p>Options for specifying the file's content are:
  :url url          - download the specified url to the given filepath
  :content string   - use the specified content directly
  :local-file path  - use the file on the local machine at the given path
  :remote-file path - use the file on the remote machine at the given path
  :link             - file to link to
  :literal          - prevent shell expansion on content
  :md5              - md5 for file
  :md5-url          - a url containing file's md5
  :template         - specify a template to be interpolated
  :values           - values for interpolation
  :blob             - map of :container, :path
  :blobstore        - a jclouds blobstore object (override blobstore in request)</p>

<p>Options for version control are:
  :overwrite-changes - flag to force overwriting of locally modified content
  :no-versioning    - do not version the file
  :max-versions     - specfy the number of versions to keep (default 5)
  :flag-on-changed  - flag to set if file is changed</p>

<p>Options for specifying the file's permissions are:
  :owner user-name
  :group group-name
  :mode  file-mode</p>

<p>To copy the content of a local file to a remote file:
    (remote-file request "remote/path" :local-file "local/path")</p>

<p>To copy the content of one remote file to another remote file:
    (remote-file request "remote/path" :remote-file "remote/source/path")</p>

<p>To link one remote file to another remote file:
    (remote-file request "remote/path" :link "remote/source/path")</p>

<p>To download a url to a remote file:
    (remote-file request "remote/path" :url "http://a.com/path")</p>

<p>If a url to a md5 file is also available, then it can be specified to prevent
unnecessary downloads and to verify the download.
    (remote-file request "remote/path"
      :url "http://a.com/path"
      :md5-url "http://a.com/path.md5")</p>

<p>If the md5 of the file to download, it can be specified to prevent unnecessary
downloads and to verify the download.
    (remote-file request "remote/path"
      :url "http://a.com/path"
      :md5 "6de9439834c9147569741d3c9c9fc010")</p>

<p>Content can also be copied from a blobstore.
    (remote-file request "remote/path"
      :blob {:container "container" :path "blob"})</p>
</td><td class="codes" /><pre class="brush: clojure">(defn remote-file
  "Remote file content management.
The `remote-file` resource can specify the content of a remote file in a number
different ways.
By default, the remote-file is versioned, and 5 versions are kept.
The remote content is also verified against it's md5 hash.  If the contents
of the remote file have changed (e.g. have been edited on the remote machine)
then by default the file will not be overwritten, and an error will be raised.
To force overwrite, call `set-force-overwrite` before running `converge` or
`lift`.
Options for specifying the file's content are:
  :url url          - download the specified url to the given filepath
  :content string   - use the specified content directly
  :local-file path  - use the file on the local machine at the given path
  :remote-file path - use the file on the remote machine at the given path
  :link             - file to link to
  :literal          - prevent shell expansion on content
  :md5              - md5 for file
  :md5-url          - a url containing file's md5
  :template         - specify a template to be interpolated
  :values           - values for interpolation
  :blob             - map of :container, :path
  :blobstore        - a jclouds blobstore object (override blobstore in request)
Options for version control are:
  :overwrite-changes - flag to force overwriting of locally modified content
  :no-versioning    - do not version the file
  :max-versions     - specfy the number of versions to keep (default 5)
  :flag-on-changed  - flag to set if file is changed
Options for specifying the file's permissions are:
  :owner user-name
  :group group-name
  :mode  file-mode
To copy the content of a local file to a remote file:
    (remote-file request \"remote/path\" :local-file \"local/path\")
To copy the content of one remote file to another remote file:
    (remote-file request \"remote/path\" :remote-file \"remote/source/path\")
To link one remote file to another remote file:
    (remote-file request \"remote/path\" :link \"remote/source/path\")
To download a url to a remote file:
    (remote-file request \"remote/path\" :url \"http://a.com/path\")
If a url to a md5 file is also available, then it can be specified to prevent
unnecessary downloads and to verify the download.
    (remote-file request \"remote/path\"
      :url \"http://a.com/path\"
      :md5-url \"http://a.com/path.md5\")
If the md5 of the file to download, it can be specified to prevent unnecessary
downloads and to verify the download.
    (remote-file request \"remote/path\"
      :url \"http://a.com/path\"
      :md5 \"6de9439834c9147569741d3c9c9fc010\")
Content can also be copied from a blobstore.
    (remote-file request \"remote/path\"
      :blob {:container \"container\" :path \"blob\"})"
  [request path & {:keys [action url local-file remote-file link
                          content literal
                          template values
                          md5 md5-url
                          owner group mode force
                          blob blobstore
                          overwrite-changes no-versioning max-versions
                          flag-on-changed]
                   :as options}]
  (when-let [f (and local-file (io/file local-file))]
    (when (not (and (.exists f) (.isFile f) (.canRead f)))
      (throw (IllegalArgumentException.
              (format
               (str "'%s' does not exist, is a directory, or is unreadable; "
                    "cannot register it for transfer.")
               local-file)))))
  (->
   request
   (when-> local-file
           ;; transfer local file to remote system if required
           (transfer-file local-file (str path ".new")))
   (apply-map-> remote-file-resource path options)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.resource-when" name="pallet.resource.resource-when"><h1 class="project-name">pallet.resource.resource-when</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Conditional resource execution.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.resource-when
  (:require
   [pallet.stevedore :as stevedore]
   [pallet.argument :as argument]
   [pallet.resource :as resource]
   [pallet.resource-build :as resource-build]
   [pallet.resource.exec-script :as exec-script])
  (:use
   clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro resource-when
  [request condition & resources]
  `(exec-script/exec-script
    ~request
    (if ~condition
      (do (unquote (->
                    (resource-build/produce-phases
                      [(:phase ~request)]
                      ((resource/phase ~@resources) ~request))
                    first))))))</pre></tr><tr><td class="docs"><p>This is a macro, so that the condition can be wrapped in a function
preventing capture of its literal value, and ensuring that it is
specialised on target node</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro resource-when-not
  [request condition & resources]
  `(exec-script/exec-script
    ~request
    (if-not ~condition
      (do (unquote (->
                    (resource-build/produce-phases
                      [(:phase ~request)]
                      ((resource/phase ~@resources) ~request))
                    first))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.rsync" name="pallet.resource.rsync"><h1 class="project-name">pallet.resource.rsync</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.rsync
  (:require
   [pallet.compute :as compute]
   [pallet.resource :as resource]
   [pallet.resource.directory :as directory]
   [pallet.resource.package :as package]
   [pallet.stevedore :as stevedore]
   [pallet.target :as target]
   [pallet.execute :as execute]
   [pallet.utils :as utils]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def cmd "/usr/bin/rsync -e '%s' -rP --delete --copy-links -F -F %s %s@%s:%s")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(resource/deflocal rsync
  (rsync*
   [request from to {:keys [port]}]
   (logging/info (format "rsync %s to %s" from to))
   (let [ssh (str "/usr/bin/ssh -o \"StrictHostKeyChecking no\" "
                  (if port (format "-p %s" port)))
         cmd (format
              cmd ssh from (:username utils/*admin-user*)
              (compute/primary-ip (:target-node request)) to)]
     (execute/sh-script cmd)
     request)))</pre></tr><tr><td class="docs"><p>Rsync from a local directory to a remote directory.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn rsync-directory
  [request from to & {:keys [owner group mode port] :as options}]
  (->
   request
   (package/package "rsync")
   (directory/directory to :owner owner :group group :mode mode)
   (rsync from to options)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.service" name="pallet.resource.service"><h1 class="project-name">pallet.resource.service</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Service control.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.service
  (:use clojure.contrib.logging)
  (:require
   [pallet.script :as script]
   [pallet.stevedore :as stevedore]
   [pallet.resource.filesystem-layout :as filesystem-layout]
   [pallet.resource.lib :as lib]
   [pallet.resource.remote-file :as remote-file]
   [pallet.resource :as resource]
   [clojure.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(script/defscript configure-service
  [name action options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def debian-configure-option-names
     {:force :f})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn debian-options [options]
  (zipmap
   (map #(% debian-configure-option-names %) (keys options))
   (vals options)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl configure-service :default [name action options]
  ~(condp = action
       :disable (stevedore/script
                 (update-rc.d
                  ~(stevedore/map-to-arg-string
                    (select-keys [:f :n] (debian-options options)))
                  ~name remove))
       :enable (stevedore/script
                (update-rc.d
                 ~(stevedore/map-to-arg-string
                   (select-keys [:n] (debian-options options)))
                 ~name defaults
                 ~(:sequence-start options 20)
                 ~(:sequence-stop options (:sequence-start options 20))))
       :start-stop (stevedore/script ;; start/stop
                    (update-rc.d
                     ~(stevedore/map-to-arg-string
                       (select-keys [:n] (debian-options options)))
                     ~name
                     start ~(:sequence-start options 20)
                     "."
                     stop ~(:sequence-stop options (:sequence-start options 20))
                     "."))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def ^{:private true} chkconfig-default-options
  [20 2 3 4 5])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- chkconfig-levels
  [options]
  (->> options (drop 1 ) (map str) string/join))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(stevedore/defimpl configure-service [#{:yum}] [name action options]
  ~(condp = action
       :disable (stevedore/script ("/sbin/chkconfig" ~name off))
       :enable (stevedore/script
                ("/sbin/chkconfig"
                 ~name on
                 "--level" ~(chkconfig-levels
                             (:sequence-start
                              options chkconfig-default-options))))
       :start-stop (stevedore/script ;; start/stop
                    ("/sbin/chkconfig"
                     ~name on
                     "--level" ~(chkconfig-levels
                                 (:sequence-start
                                  options chkconfig-default-options))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(resource/defresource service
  "Control services.

   - :action  accepts either startstop, restart, enable or disable keywords.
   - :if-flag  makes start, stop, and restart confitional on the specified flag
               as set, for example, by remote-file :flag-on-changed
   - :sequence-start  a sequence of [sequence-number level level ...], where
                      sequence number determines the order in which services
                      are started within a level."
  (service*
   [request service-name & {:keys [action if-flag]
                            :or {action :start}
                            :as options}]
   (if (#{:enable :disable :start-stop} action)
     (stevedore/checked-script
      (format "Confgure service %s" service-name)
      (configure-service ~service-name ~action ~options))
     (if if-flag
       (stevedore/script
        (if (== "1" (flag? ~if-flag))
          (~(str "/etc/init.d/" service-name) ~(name action))))
       (stevedore/script
        ( ~(str "/etc/init.d/" service-name) ~(name action)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-restart
  "Stop the given service, execute the body, and then restart."
  [request service-name & body]
  `(let [service# ~service-name]
     (-> ~request
         (service service# :action :stop)
         ~@body
         (service service# :action :start))))</pre></tr><tr><td class="docs"><p>Install an init script.  Sources as for remote-file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn init-script
  [request name & {:keys [action url local-file remote-file link
                          content literal template values md5 md5-url force]
                   :or {action :create}
                   :as options}]
  (apply
   remote-file/remote-file
   request
   (str (stevedore/script (etc-init)) "/" name)
   :action action :owner "root" :group "root" :mode "0755"
   (apply concat options)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource.user" name="pallet.resource.user"><h1 class="project-name">pallet.resource.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>User management resource.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource.user
  (:use
   pallet.script
   [pallet.resource :only [defresource defaggregate]]
   pallet.stevedore
   [clojure.contrib.def :only [defvar-]]
   clojure.contrib.logging)
  (:require
   [clojure.contrib.string :as string]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defscript user-exists? [name])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defscript modify-user [name options])
(defscript create-user [name options])
(defscript remove-user [name options])
(defscript lock-user [name])
(defscript unlock-user [name])
(defscript user-home [username])
(defscript current-user [])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defscript group-exists? [name])
(defscript modify-group [name options])
(defscript create-group [name options])
(defscript remove-group [name options])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl user-exists? :default [username]
  (getent passwd ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl create-user :default [username options]
  ("/usr/sbin/useradd" ~(map-to-arg-string options) ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl create-user [#{:rhel :centos :amzn-linux}] [username options]
  ("/usr/sbin/useradd"
   ~(-> options
        (assoc :r (:system options))
        (dissoc :system)
        map-to-arg-string)
   ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl modify-user :default [username options]
  ("/usr/sbin/usermod" ~(map-to-arg-string options) ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl remove-user :default [username options]
  ("/usr/sbin/userdel" ~(map-to-arg-string options) ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl lock-user :default [username]
  ("/usr/sbin/usermod" --lock ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl unlock-user :default [username]
  ("/usr/sbin/usermod" --unlock ~username))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl user-home :default [username]
  @(getent passwd ~username | cut "-d:" "-f6"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl user-home [:os-x] [username]
  @(pipe
    (dscl localhost -read ~(str "/Local/Default/Users/" username)
          "dsAttrTypeNative:home")
    (cut -d "' '" -f 2)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl current-user :default []
  @(whoami))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl group-exists? :default [name]
  (getent group ~name))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl create-group :default [groupname options]
  ("/usr/sbin/groupadd" ~(map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl create-group [#{:rhel :centos :amzn-linux}] [groupname options]
  ("/usr/sbin/groupadd"
   ~(-> options
        (assoc :r (:system options))
        (dissoc :system)
        map-to-arg-string)
   ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl modify-group :default [groupname options]
  ("/usr/sbin/groupmod" ~(map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defimpl remove-group :default [groupname options]
  ("/usr/sbin/groupdel" ~(map-to-arg-string options) ~groupname))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defvar- shell-names
  {:bash "/bin/bash" :csh "/bin/csh" :ksh "/bin/ksh" :rsh "/bin/rsh"
   :sh "/bin/sh" :tcsh "/bin/tcsh" :zsh "/bin/zsh" :false "/bin/false"}
  "Map for looking up shell path based on keyword.")</pre></tr><tr><td class="docs"><p>Require a user</p>
</td><td class="codes" /><pre class="brush: clojure">(defn user*
  [request username & {:keys [action shell base-dir home system create-home
                              password shell comment groups remove force]
                       :or {action :manage}
                       :as options}]
  (let [opts (merge options {:shell (get shell-names shell shell)})]
    (case action
      :create
      (script
       (if-not (user-exists? ~username)
         (create-user
          ~username ~(select-keys opts [:base-dir :home :system :create-home
                                        :password :shell]))))
      :manage
      (script
       (if (user-exists? ~username)
         (modify-user
          ~username ~(select-keys opts [:home :shell :comment :groups]))
         (create-user
          ~username ~(select-keys opts [:base-dir :home :system :comment
                                        :create-home :pasword :shell
                                        :groups]))))
      :lock
      (script
       (if (user-exists? ~username)
         (lock-user ~username)))
      :unlock
      (script
       (if (user-exists? ~username)
         (unlock-user ~username)))
      :remove
      (script
       (if (user-exists? ~username)
         (remove-user ~username ~(select-keys opts [:remove :force]))))
      (throw (IllegalArgumentException.
              (str action " is not a valid action for user resource"))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defaggregate user
  "User management."
  {:copy-arglist pallet.resource.user/user*}
  (user-combiner
   [request user-args]
   (string/join \newline (map #(apply user* request %) user-args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defresource group
  "User Group Management."
  (group*
   [request groupname & {:keys [action system gid password]
                         :or {action :manage}
                         :as options}]
   (case action
     :create
     (script
      (if-not (group-exists? ~groupname)
        (create-group
         ~groupname ~(select-keys options [:system :gid :password]))))
     :manage
     (script
      (if (group-exists? ~groupname)
        (modify-group
         ~groupname ~(select-keys options [:gid :password]))
        (create-group
         ~groupname ~(select-keys options [:system :gid :password]))))
     :remove
     (script
      (if (group-exists? ~groupname)
        (remove-group ~groupname {})))
     (throw (IllegalArgumentException.
             (str action " is not a valid action for group resource"))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource" name="pallet.resource"><h1 class="project-name">pallet.resource</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Resources implement the conversion of phase functions to script and other
configuration code.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource
  (:require
   [pallet.argument :as argument]
   [pallet.script :as script]
   [clojure.contrib.seq :as seq]
   [clojure.string :as string]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging])
  (:use
   [clojure.contrib.def :only [defunbound defvar defvar- name-with-attributes]]
   clojure.contrib.core))</pre></tr><tr><td class="docs"><p>Calculate the name for the pre-phase</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pre-phase
  [phase]
  (keyword (str "pre-" (name phase))))</pre></tr><tr><td class="docs"><p>Calculate the name for the after-phase</p>
</td><td class="codes" /><pre class="brush: clojure">(defn after-phase
  [phase]
  (keyword (str "after-" (name phase))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro execute-pre-phase
  "Specify the pre phase for execution of resources."
  [request & body]
  `(let [request# ~request
         phase# (:phase request#)]
     (->
      (assoc request# :phase (pre-phase phase#))
      ~@body
      (assoc :phase phase#))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro execute-after-phase
  "Specify the after phase for execution of resources."
  [request & body]
  `(let [request# ~request
         phase# (:phase request#)]
     (->
      (assoc request# :phase (after-phase phase#))
      ~@body
      (assoc :phase phase#))))</pre></tr><tr><td class="docs"><p>Registers a resource whose generation is defined by the specified
   invocation function and arguments that will be applied to that fn
   when the associated phase is applied to a node.</p>

<p>   The invocation can be scheduled within one of two 'executions'
   (conceptually, sub-phases):</p>

<p>   :in-sequence - The generated resource will be applied to the node
        "in order", as it is defined lexically in the source crate.
        This is the default.
   :aggregated - All aggregated resources are applied to the node
        in the order they are defined, but before all :in-sequence
        resources. Note that all of the arguments to any given
        invocation fn are gathered such that there is only ever one
        invocation of each fn within each phase.
   :collected - All collected resources are applied to the node
        in the order they are defined, but after all :in-sequence
        resources. Note that all of the arguments to any given
        invocation fn are gathered such that there is only ever one
        invocation of each fn within each phase.</p>

<p>   The resource-type determines how the invocation should be handled:</p>

<p>   :script/bash - resource produce bash script for execution on remote machine
   :fn/clojure  - resource is a function for local execution
   :transfer/to-local - resource is a function specifying remote source
        and local destination.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn invoke-resource
  "Registers a resource whose generation is defined by the specified
   invocation function and arguments that will be applied to that fn
   when the associated phase is applied to a node.
   The invocation can be scheduled within one of two 'executions'
   (conceptually, sub-phases):
   :in-sequence - The generated resource will be applied to the node
        \"in order\", as it is defined lexically in the source crate.
        This is the default.
   :aggregated - All aggregated resources are applied to the node
        in the order they are defined, but before all :in-sequence
        resources. Note that all of the arguments to any given
        invocation fn are gathered such that there is only ever one
        invocation of each fn within each phase.
   :collected - All collected resources are applied to the node
        in the order they are defined, but after all :in-sequence
        resources. Note that all of the arguments to any given
        invocation fn are gathered such that there is only ever one
        invocation of each fn within each phase.
   The resource-type determines how the invocation should be handled:
   :script/bash - resource produce bash script for execution on remote machine
   :fn/clojure  - resource is a function for local execution
   :transfer/to-local - resource is a function specifying remote source
        and local destination."
  ([request invoke-fn args]
     (invoke-resource request invoke-fn args :in-sequence :script/bash))
  ([request invoke-fn args execution]
     (invoke-resource request invoke-fn args execution :script/bash))
  ([request invoke-fn args execution resource-type]
     {:pre [request
            (keyword? (:phase request))
            (keyword? (:target-id request))]}
     (let [[execution location] (if (#{:fn/clojure :transfer/to-local}
                                     resource-type)
                                  [:in-sequence :local]
                                  [execution :remote])]
       (update-in
        request
        [:invocations (:phase request) (:target-id request) execution]
        #(conj
          (or % [])
          {:f invoke-fn
           :args args
           :location location
           :type resource-type})))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- group-by-function
  "Transforms a seq of invocations, generally some with identical :f values
   into a sequence of invocations where the :args are the concatenation of all
   of the :args of associated with each :f in the original seq.  Sequence order
   from the original seq is retained. Keys over than :f and :args are assumed
   identical for a given :f value.

   e.g. (group-by-function
           [{:f :a :args [1 2]}
            {:f :b :args [3 4]}
            {:f :a :args [5 6]}
            {:f :c :args [7 8]]])
        => ({:f :a :args ([1 2] [5 6])}
            {:f :c :args ([7 8])}
            {:f :b :args ([3 4])})"
  [invocations]
  (loop [groups []
         [{:keys [f] :as invocation} & more :as all] invocations]
    (if-not invocation
      (for [invocations groups]
        (assoc (first invocations)
          :args (map :args invocations)))
      (let [[matching rest] (seq/separate #(= (:f %) f) all)]
        (recur (conj groups matching) rest)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn apply-evaluated
  [f args request]
  (apply f request (map #(when % (argument/evaluate % request)) args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn apply-aggregated-evaluated
  [f args request]
  (f
   request
   (map
    #(map (fn [x] (when x (argument/evaluate x request))) %)
    args)))</pre></tr><tr><td class="docs"><p>Given an execution's invocations, will return a seq of
   functions pre-processed appropriately for that execution.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti invocations->resource-fns
  (fn [execution invocations] execution))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod invocations->resource-fns :in-sequence
  [_ invocations]
  (for [{:keys [f args location type]} invocations]
    {:location location
     :f (partial apply-evaluated f args)
     :type type}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod invocations->resource-fns :aggregated
  [_ invocations]
  (for [{:keys [f args location type]} (group-by-function invocations)]
    {:location location
     :f (partial apply-aggregated-evaluated f args)
     :type type}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod invocations->resource-fns :collected
  [_ invocations]
  (for [{:keys [f args location type]} (group-by-function invocations)]
    {:location location
     :f (partial apply-aggregated-evaluated f args)
     :type type}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defvar- execution-ordering [:aggregated :in-sequence :collected])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compare-resource-sequence
  [x y]
  (let [before-fn (fn [f]
                    (let [before (:always-before (meta f))
                          before (if (or (set? before) (nil? before))
                                   before
                                   #{before})
                          before (seq (filter identity (map find-var before)))]
                      (into #{} (map (comp :resource-fn meta) before))))
        fx (:f x)
        fy (:f y)]
    (cond
     ((before-fn fx) (var-get fy)) -1
     ((before-fn fy) (var-get fx)) 1
     :else 0)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- execution-invocations
  "Sort by execution-ordering"
  [invocations]
  (map
   #(vector % (sort compare-resource-sequence (% invocations)))
   execution-ordering))</pre></tr><tr><td class="docs"><p>Configured resources for executions, binding args to methods.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn bound-invocations
  [invocations]
  (apply
   concat
   (for [[execution invocations] (execution-invocations invocations)]
     (invocations->resource-fns execution invocations))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn arglist-finder [v]
  (or (-?> (:copy-arglist v) resolve meta :arglists first)
      (:use-arglist v)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defresource
  "Defines a resource-producing functions.  Takes a name, a vector specifying
   the symbol to bind the request to and an optional execution phase and backing
   function arguments, the argument signature that the function exposes and the
   body of the resource.

   A \"backing function\" that will actually produce the resource is defined
   with name*."
  [name & args]
  (let [[name args] (name-with-attributes name args)
        [body] args
        apply-fn (first body)       ;(symbol (str (clojure.core/name name) "*"))
        argv (second body)
        execution (::execution (meta name) :in-sequence)
        type (::type (meta name) :script/bash)
        arglist (or (arglist-finder (meta name)) argv)
        ;; remove so not used in an evaluated context
        name (with-meta name
               (->
                (meta name)
                (dissoc :use-arglist :copy-arglist)
                (assoc :resource-fn (first body))))]
    (assert (pos? (count argv)))        ; mandatory result argument
    `(do
       (defn ~(with-meta (first body) (dissoc (meta name) :resource-fn))
         ~@(rest body))
       (defn ~name
         {:arglists '(~arglist)}
         [& [~@arglist :as argv#]]
         (invoke-resource
          ~(first arglist)
          #'~apply-fn
          (rest argv#)
          ~execution
          ~type)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deflocal
  "Shortcut for defining a resource-producing function with an
   :execution of :in-sequence. and ::type of :fn/clojure"
  [name & args]
    (let [[name args] (name-with-attributes name args)]
    `(defresource
       ~name
       {::execution :in-sequence ::type :fn/clojure}
       ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defaggregate
  "Shortcut for defining a resource-producing function with an
    :execution of :aggregate. The option vector specifes the
    backing function arguments."
  [name & args]
  (let [[name args] (name-with-attributes name args)
        attr (merge (or (meta name) {})
                    {::execution :aggregated ::type :script/bash})]
    `(defresource ~name ~attr ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defcollect
  "Shortcut for defining a resource-producing function with an
    :execution of :collect. The option vector specifes the
    backing function arguments."
  [name & args]
    (let [[name args] (name-with-attributes name args)
          attr (merge (or (meta name) {})
                      {::execution :collected ::type :script/bash})]
    `(defresource ~name ~attr ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(deflocal as-local-resource
  "An adaptor for using a normal function as a local resource function"
  (as-local-resource*
   [request f & args]
   (apply f request args)))</pre></tr><tr><td class="docs"><p>Concatenate multiple scripts, removing blank lines</p>
</td><td class="codes" /><pre class="brush: clojure">(defn script-join
  [scripts]
  (str
   (string/join \newline
     (filter (complement string/blank?) (map #(when % (string/trim %)) scripts)))
   \newline))</pre></tr><tr><td class="docs"><p>Create a resource evaluation function that combines the evaluation</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti resource-evaluate-fn
  (fn [type & _] type))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resource-evaluate-transfer-fn
  [type location s]
  (fn [request]
    {:type type
     :location location
     :transfers (map #((:f %) request) s)
     :request request}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod resource-evaluate-fn :transfer/from-local
  [type location s]
  (resource-evaluate-transfer-fn type location s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod resource-evaluate-fn :transfer/to-local
  [type location s]
  (resource-evaluate-transfer-fn type location s))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod resource-evaluate-fn :script/bash
  [type location s]
  (fn [request]
    {:type type
     :location location
     :cmds (script-join (map #((:f %) request) s))
     :request request}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod resource-evaluate-fn :fn/clojure
  [type location s]
  (fn [request]
    {:type type
     :location location
     :request (reduce #((:f %2) %1) request s)}))</pre></tr><tr><td class="docs"><p>Build an execution list for the passed resources.  The result is a sequence
   of [location type f] maps, where location is either :local or :remote, and f
   returns a string for remote execution, or is a no argument function for local
   execution.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn output-resources
  [resources]
  {:pre [(or (map? resources) (nil? resources))
         (every?
          #{:in-sequence :aggregated :collected}
          (keys resources))
         (every? vector? (vals resources))]}
  (for [s (partition-by
           (juxt :location :type) (bound-invocations resources))]
    {:location (:location (first s))
     :type (:type (first s))
     :f (resource-evaluate-fn
         (:type (first s)) (:location (first s)) s)}))</pre></tr><tr><td class="docs"><p>Produce the :phase phase from the :invocations</p>
</td><td class="codes" /><pre class="brush: clojure">(defn produce-phase
  [request]
  {:pre [(keyword? (:phase request))
         (keyword? (:target-id request))]}
  (let [phase (:phase request)
        target-id (:target-id request)]
    (seq (output-resources
          (-> request :invocations phase target-id)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn script-template [request]
  (let [family (-> request :node-type :image :os-family)]
    (filter identity
            [family
             (-> request :target-packager)
             (if-let [version (-> request :node-type :image :os-version)]
               (keyword (format "%s-%s" (name family) version)))])))</pre></tr><tr><td class="docs"><p>Execute a resource of the given type.  Returns [request result]</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti execute-resource
  (fn [request resource-type & _] resource-type))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod execute-resource :script/bash
  [request resource-type execute-fn f]
  (script/with-template (script-template request)
    (let [{:keys [cmds request location resource-type]} (f request)]
      [request (execute-fn cmds)])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod execute-resource :transfer/to-local
  [request resource-type execute-fn f]
  (script/with-template (script-template request)
    (let [{:keys [transfers request location resource-type]} (f request)]
      [request (execute-fn transfers)])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod execute-resource :transfer/from-local
  [request resource-type execute-fn f]
  (script/with-template (script-template request)
    (let [{:keys [transfers request location resource-type]} (f request)]
      [request (execute-fn transfers)])))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod execute-resource :fn/clojure
  [request resource-type execute-fn f]
  [(:request (or (and execute-fn (execute-fn f request))
                 (f request)))
   nil])</pre></tr><tr><td class="docs"><p>Execute commands by passing the evaluated resources to the function of the
   correct type in fn-map.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn execute-commands
  [request fn-map]
  (loop [[{:keys [location type f] :as command}
          & rest :as commands] (:commands request)
          request request
          result []]
    (if command
      (let [[request fn-result] (execute-resource request type (type fn-map) f)]
        (recur rest request (if fn-result (conj result fn-result) result)))
      [result request])))</pre></tr><tr><td class="docs"><p>Add pre and after phases</p>
</td><td class="codes" /><pre class="brush: clojure">(defn phase-list*
  [phases]
  (lazy-seq
   (when (seq phases)
     (let [phase (first phases)]
       (if (keyword? phase)
         (cons (pre-phase phase)
               (cons phase
                     (cons (after-phase phase)
                           (phase-list* (rest phases)))))
         (cons (pre-phase (first phase))
               (cons phase
                     (cons [(after-phase (first phase)) (second phase)]
                           (phase-list* (rest phases))))))))))</pre></tr><tr><td class="docs"><p>Add default phases, pre and after phases.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn phase-list
  [phases]
  (phase-list* (or (seq phases) (seq [:configure]))))</pre></tr><tr><td class="docs"><p>Function that can check a request map to ensure it is a valid part of
   phase definiton. It returns the request map.</p>

<p>   If this fails, then it is likely that you have an incorrect crate function,
   which is failing to return its request map properly, or you have a non crate
   function in the phase defintion.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn check-request-map
  ([request]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and request (map? request))
       (condition/raise
        :type :invalid-request-map
        :message
        "Invalid request map in phase. Check for non crate functions,
      improper crate functions, or problems in threading the request map
      in your phase definition.
      A crate function is a function that takes a request map and other
      arguments, and returns a modified request map. Calls to crate functions
      are often wrapped in a threading macro, -> or pallet.resource/phase,
      to simplify chaining of the request map argument."))
     request)
  ([request form]
     ;; we do not use a precondition in order to improve the error message
     (when-not (and request (map? request))
       (condition/raise
        :type :invalid-request-map
        :message
        (format
         (str
          "Invalid request map in phase request.\n"
          "Problem probably caused in:\n  %s ")
         form)))
     request))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro phase
  "Create a phase function from a sequence of crate invocations with
   an ommited request parameter.

   eg. (phase
         (file \"/some-file\")
         (file \"/other-file\"))

   which generates a function with a request argument, that is thread
   through the function calls. The example is thus equivalent to:

   (fn [request] (-> request
                   (file \"/some-file\")
                   (file \"/other-file\"))) "
  [& body]
  `(fn [request#]
     (->
      request#
      (check-request-map "The request passed to the pipeline")
      ~@(mapcat (fn [form] [form `(check-request-map '~form)]) body))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.resource-build" name="pallet.resource-build"><h1 class="project-name">pallet.resource-build</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Temporary namespace - needs to move to testing, but need to resource-when</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.resource-build
  (:require
   [pallet.resource :as resource]
   [pallet.compute :as compute]
   [pallet.script :as script]
   [clojure.string :as string]))</pre></tr><tr><td class="docs"><p>Join the result of produce-phase, executing local resources.
   Useful for testing.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn produce-phases
  [phases request]
  (clojure.contrib.logging/trace
   (format "produce-phases %s %s" phases request))
  (let [execute
        (fn [request]
          (let [commands (resource/produce-phase request)
                [result request] (if commands
                                   (resource/execute-commands
                                    (assoc request :commands commands)
                                    {:script/bash (fn [cmds] cmds)
                                     :transfer/from-local (fn [& _])
                                     :transfer/to-local (fn [& _])})
                                   [nil request])]
            [(string/join "" result) request]))]
    (reduce
     #(let [[result request] (execute (assoc (second %1) :phase %2))]
        [(str (first %1) result) request])
     ["" request]
     (resource/phase-list phases))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro build-resources
  "Outputs the remote resources specified in the body for the specified phases.
   This is useful in testing."
  [[& {:as request-map}] & body]
  `(let [f# (resource/phase ~@body)
         request# (or ~request-map {})
         request# (update-in request# [:phase]
                             #(or % :configure))
         request# (update-in request# [:node-type :image :os-family]
                             #(or % :ubuntu))
         request# (update-in request# [:node-type :tag]
                             #(or % :id))
         request# (update-in request# [:target-id]
                             #(or %
                                  (and (:target-node request#)
                                       (keyword
                                        (compute/id (:target-node request#))))
                                  :id))
         request# (update-in request# [:all-nodes]
                             #(or % [(:target-node request#)]))
         request# (update-in request# [:target-nodes]
                             #(or % (:all-nodes request#)))
         request# (update-in
                   request# [:target-packager]
                   #(or
                     %
                     (get-in request# [:node-type :image :packager])
                     (let [os-family# (get-in
                                       request#
                                       [:node-type :image :os-family])]
                       (cond
                        (#{:ubuntu :debian :jeos :fedora} os-family#) :aptitude
                        (#{:centos :rhel} os-family#) :yum
                        (#{:arch} os-family#) :pacman
                        (#{:suse} os-family#) :zypper
                        (#{:gentoo} os-family#) :portage))))]
     (script/with-template
       [(-> request# :node-type :image :os-family)
        (-> request# :target-packager)]
       (produce-phases [(:phase request#)] (f# request#)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.script" name="pallet.script"><h1 class="project-name">pallet.script</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Base infrastructure for script generation, and operating system abstraction.</p>

<p>   <code>defscript</code> defines an abstract script function, that can be implemented
   for different operating system (and version) targets.</p>

<p>   <code>implement</code> is used to add an implementation to a function defined with
   <code>defscript</code>.</p>

<p>   Dispatch of <code>defscript</code> is based on an implementation's specialisers vector.
   All elements of the specialisers vector must match <code>*template*</code>.  The
   specialisers vector may contain keywords that match if the are in
   <code>*template*</code>, sets of keywords that match if any of the set values are in
   <code>*template*</code>, or functions that will be passed <code>*template*</code> as an argument
   and should return a truth value indicating whether a match occured.</p>

<p>   Mutiple implementations may match the <code>*template*</code> vector, and the
   best fit is determined by the highest number of matching specialiser
   functions, with ties decided by the earliest defined implementation.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.script
  (:require
   [clojure.contrib.def :as def]
   [clojure.contrib.condition :as condition]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>map from script name to implementations
where implementations is a map from keywords to function</p>
</td><td class="codes" /><pre class="brush: clojure">(defonce scripts (atom {}))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def *script-line* nil)
(def *script-file* nil)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def/defunbound *template*
  "Determine the target to generate script for.
   `defscript` implementations are dispatched on this.  The value should
   be a vector, containing os-family values (e.g. `:ubuntu`), os-family and
   os-version values (e.g. `:centos-5.3`), or other keywords.")</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-template
  "Specify the target for script generation. `template` should be a vector of
   os-family, os-family and os-version, or other keywords. "
  [template & body]
  `(binding [*template* (filter identity ~template)]
     ~@body))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-line-number
  "Provide the source file and line number for use in reporting."
  [[file line] & body]
  `(do
     (binding [*script-line* ~line
               *script-file* ~file]
       ~@body)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- print-args
  "Utitlity function to print arguments for logging"
  [args]
  (str "(" (apply str (interpose " " args)) ")"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- match-fn
  "Determines if a given `defscript` implementation specialiser matches
   `*template*`.
     - A keyword specialiser matches if the keyword is in `*template*`.
     - A set specialiser matches if any of the `*template*` keywords
       are in the set
     - A function specialiser matches if it returns true when passed
      `*template*`"
  [specialiser]
  {:pre [*template* (seq *template*)]}
  (cond
   (keyword? specialiser) (some #(= specialiser %) *template*)
   (set? specialiser) (some #(specialiser %) *template*)
   :else (specialiser *template*)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- matches?
  "Return the keys that match the template, or nil if any of the keys are not in
   the template."
  [keys]
  (every? match-fn keys))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- more-explicit?
  "Predicate to test whether `candidate` is a more explicit specialiser vector
   than `current`"
  [current candidate]
  (or (= current :default)
      (> (count candidate) (count current))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- better-match?
  "Predicate to test whether `candidate` is a better matched specialiser vector
   than `current`. `candidate` is first checked to see if it matches the
   current `*template*`"
  [current candidate]
  (if (and (matches? (first candidate))
           (more-explicit? (first current) (first candidate)))
    candidate
    current))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- best-match
  "Determine the best matching implementation of `script` for the current
   `*template*`"
  [script]
  (logging/trace
   (format "Looking up script %s" script))
  (when-let [impls (@scripts script)]
    (logging/trace
     (format
      "Found implementations %s - template %s" (keys impls) (seq *template*)))
    (second (reduce better-match?
                    [:default (impls :default)]
                    (dissoc impls :default)))))</pre></tr><tr><td class="docs"><p>Invoke <code>script</code> with the given <code>args</code>.  The implementations of <code>script</code> is
   found based on the current <code>*template*</code> value.  If no matching
   implementation is found, then a :no-script-implementation condition
   is raised.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn dispatch-target
  [script & args]
  (logging/trace (str "dispatch-target " script " " (print-args ~@args)))
  (let [f (best-match script)]
    (if f
      (apply f args)
      (condition/raise
       :type :no-script-implementation
       :template *template*
       :file *script-file*
       :line *script-line*
       :message (format
                 "No implementation for %s with template %s"
                 (name script)
                 (pr-str *template*))))))</pre></tr><tr><td class="docs"><p>Invoke <code>script</code> with the given <code>args</code>.  The implementations of <code>script</code> is
   found based on the current <code>*template*</code> value.  If no matching
   implementation is found, then nil is returned.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn invoke-target
  [script args]
  (logging/trace
   (format
    "invoke-target [%s:%s] %s %s"
    *script-file* *script-line* script (print-args args)))
  (when-let [f (best-match (keyword (name script)))]
    (logging/trace
     (format "Found implementation for %s - %s invoking with %s empty? %s"
             script f (print-args args) (empty? args)))
    (apply f args)))</pre></tr><tr><td class="docs"><p>TODO - ensure that metadata is correctly placed on the generated function</p>
</td><td class="codes" /><pre class="brush: clojure">(defmacro defscript
  "Define an abstract script function, that can be implemented differently for
   different operating systems.
   Calls to functions defined by `defscript` are dispatched based on the
   `*template*` vector."
  [name & args]
  (let [[name [args]] (def/name-with-attributes name args)
        fwd-args (filter #(not (= '& %)) args)]
    `(defn ~name [~@args]
       ~(if (seq fwd-args)
          `(apply dispatch-target (keyword (name ~name)) ~@fwd-args)
          `(dispatch-target (keyword (name ~name)))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- add-to-scripts
  [scripts script-name specialisers f]
  (assoc-in scripts [script-name specialisers] f))</pre></tr><tr><td class="docs"><p>Add an implementation of script-name for the given specialisers.
   The default implementation can be set by passing :default as the
   <code>specialisers</code> argument. <code>specialisers</code> should be the :default keyword, or a
   vector.  The <code>specialisers</code> vector may contain keywords, a set of keywords
   that provide an inclusive <code>or</code> match, or functions that return a truth value
   indication whether the implementation is a match for the <code>*template*</code> passed
   as the function's first argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn implement
  [script-name specialisers f]
  (swap!
   scripts
   (fn add-implementation-fn [current]
     (add-to-scripts current (keyword (name script-name)) specialisers f))))</pre></tr><tr><td class="docs"><p>Remove all implementations of a script.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn remove-script
  [script-name]
  (swap!
   scripts
   (fn remove-script-fn [current]
     (dissoc current (keyword (name script-name))))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.stevedore" name="pallet.stevedore"><h1 class="project-name">pallet.stevedore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Embed shell script in clojure.</p>

<p>   Shell script is embedded by wrapping in the <code>script</code> macro.
       (script (ls)) => "ls"</p>

<p>   The result of a <code>script</code> form is a string.</p>

<p>   Script functions (defined with <code>pallet.script/defscript</code>) can be implemented
   using <code>defimpl</code>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.stevedore
  "Embed shell script in clojure.
   Shell script is embedded by wrapping in the `script` macro.
       (script (ls)) => \"ls\"
   The result of a `script` form is a string.
   Script functions (defined with `pallet.script/defscript`) can be implemented
   using `defimpl`."
  (:require
   [pallet.utils :as utils]
   [pallet.script :as script]
   [clojure.string :as string]
   [clojure.contrib.condition :as condition]
   [clojure.walk :as walk]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>Drops first n characters from s.  Returns an empty string if n is
  greater than the length of s.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn ^String substring
  [n ^String s]
  (if (< (count s) n)
    ""
    (.substring s n)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- ^String add-quotes
  "Add quotes to the argument s as a string"
  [s]
  (str "\"" s "\""))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defonce
  ^{:doc
    "bash library for associative arrays in bash 3. You need to include this in
     your script if you use associative arrays, e.g. with `assoc!`."}
  hashlib (utils/slurp-resource "stevedore/hashlib.bash"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def statement-separator "\n")</pre></tr><tr><td class="docs"><p>Emit an expression as a valid shell statement, with separator.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn statement
  [expr]
  ;; check the substring count, as it can be negative if there is a syntax issue
  ;; in a stevedore expression, and generates a cryptic error message otherwise
  (let [n (- (count expr) (count statement-separator))]
    (if (and (pos? n) (not (= statement-separator (.substring expr n))))
      (str expr statement-separator)
      expr)))</pre></tr><tr><td class="docs"><p>Emit a shell expression as a string. Dispatched on the :type of the
   expression.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti emit
  (fn [ expr ] (type expr)))</pre></tr><tr><td class="docs"><p>null</p>
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit nil [expr])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit java.lang.Integer [expr]
  (str expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.Ratio [expr]
  (str (float expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.Keyword [expr]
  (name expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit java.lang.String [expr]
  expr)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.Symbol [expr]
  (str expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit :default [expr]
  (str expr))</pre></tr><tr><td class="docs"><p>Emit a collection as a parentesised, comma separated list.
       (comma-list [a b c]) => "(a, b, c)"</p>
</td><td class="codes" /><pre class="brush: clojure">(defn comma-list
  "Emit a collection as a parentesised, comma separated list.
       (comma-list [a b c]) => \"(a, b, c)\""
  [coll]
  (str "(" (string/join ", " coll) ")"))</pre></tr><tr><td class="docs"><p>Emit a collection as a space separated list.
       (splice-list [a b c]) => "a b c"</p>
</td><td class="codes" /><pre class="brush: clojure">(defn splice-list
  "Emit a collection as a space separated list.
       (splice-list [a b c]) => \"a b c\""
  [coll]
  (string/join " " coll))</pre></tr><tr><td class="docs"><p>Special forms are handled explcitly by an implementation of
     <code>emit-special</code>.</p>

<ul>
<li>Keyword and Operator Classes</li>
</ul>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc
    :private true}
  special-forms
  #{'if 'if-not 'when 'case 'aget 'aset 'get 'defn 'return 'set! 'var 'defvar
    'let 'local 'literally 'deref 'do 'str 'quoted 'apply
    'file-exists? 'directory? 'symlink? 'readable? 'writeable?
    'not 'println 'print 'group 'pipe 'chain-or
    'chain-and 'while 'doseq 'merge! 'assoc! 'alias})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def infix-operators
  ^{:doc "Operators that should be converted to infix in expressions."
    :private true}
  #{'+ '- '/ '* '% '== '= '< '> '<= '>= '!= '<< '>> '<<< '>>> '& '| '&& '||
    'and 'or})</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def logical-operators
  ^{:doc "Logical operators for test expressions."
    :private true}
  #{'== '= '< '> '<= '>= '!= '<< '>> '<<< '>>> '& '| '&& '||
    'file-exists? 'directory? 'symlink? 'readable? 'writeable? 'not 'and 'or})</pre></tr><tr><td class="docs"><p>Operators that should quote their arguments.</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc 
    :private true}
  quoted-operators
  (disj logical-operators 'file-exists? 'directory? 'symlink 'can-read))</pre></tr><tr><td class="docs"><p>Conversion from clojure operators to shell infix operators.</p>
</td><td class="codes" /><pre class="brush: clojure">(def
  ^{:doc 
    :private true}
  infix-conversions
     {'&& "-a"
      'and "-a"
      '|| "-o"
      'or "-o"
      '< "\\<"
      '> "\\>"
      '= "=="})</pre></tr><tr><td class="docs"><p>Predicates for keyword/operator classes</p>
</td><td class="codes" /><pre class="brush: clojure">(defn- special-form?
  "Predicate to check if expr is a special form"
  [expr]
  (contains? special-forms expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- compound-form?
  "Predicate to check if expr is a compound form"
  [expr]
  (= 'do  (first expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- infix-operator?
  "Predicate to check if expr is an infix operator"
  [expr]
  (contains? infix-operators expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- logical-operator?
  "Predicate to check if expr is a logical operator"
  [expr]
  (contains? logical-operators expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- quoted-operator?
  "Predicate to check if expr is a quoted operator"
  [expr]
  (contains? quoted-operators expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- logical-test? [test]
  (and (sequential? test)
       (or (infix-operator? (first test))
           (logical-operator? (first test)))))</pre></tr><tr><td class="docs"><p>Emit special forms</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- emit-quoted-if-not-subexpr [f expr]
  (let [s (emit expr)]
    (if (or (.startsWith s "\\(")
            (.startsWith s "!")
            (.startsWith s "-")
            (.startsWith s "@"))
      s
      (f s))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- emit-infix [type [operator & args]]
  (when (< (count args) 2)
    (throw (Exception. "Less than 2 infix arguments not supported yet.")))
  (let [open (if (logical-operator? operator) "\\( " "(")
        close (if (logical-operator? operator) " \\)" ")")
        quoting (if (quoted-operator? operator) add-quotes identity)]
    (str open (emit-quoted-if-not-subexpr quoting (first args)) " "
         (get infix-conversions operator operator)
         " " (emit-quoted-if-not-subexpr quoting (second args)) close)))</pre></tr><tr><td class="docs"><p>Emit a shell form as a string. Dispatched on the first element of the form.</p>
</td><td class="codes" /><pre class="brush: clojure">(defmulti emit-special
  (fn [ & args] (identity (first args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'file-exists? [type [file-exists? path]]
  (str "-e " (emit path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'directory? [type [directory? path]]
  (str "-d " (emit path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'symlink?
  [type [symlink? path]]
  (str "-h " (emit path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'readable?
  [type [readable? path]]
  (str "-r " (emit path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'writeable?
  [type [readable? path]]
  (str "-w " (emit path)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'not [type [not expr]]
  (str "! " (emit expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'local [type [local name expr]]
  (str "local " (emit name) "=" (emit expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- check-symbol [var-name]
  (when (re-matches #".*-.*" var-name)
    (condition/raise
     :type :invalid-bash-symbol
     :message (format "Invalid bash symbol %s" var-name)))
  var-name)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- munge-symbol [var-name]
  (let [var-name (string/replace var-name "-" "__")
        var-name (string/replace var-name "." "_DOT_")
        var-name (string/replace var-name "/" "_SLASH_")]
    var-name))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- set-map-values
  [var-name m]
  (str "{ "
         (string/join ""
          (map
           #(format "hash_set %s %s %s; "
                    (munge-symbol (emit var-name))
                    (munge-symbol (emit (first %)))
                    (emit (second %)))
           m))
         " }"))</pre></tr><tr><td class="docs"><p>This requires bash 4
(str
"{ "
"declare -a " (emit var-name) "; "
(check-symbol (emit var-name)) "=" (emit expr)
"; }")</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'var [type [var var-name expr]]
  (if (instance? clojure.lang.IPersistentMap expr)
    (set-map-values var-name expr)
    (str
     (check-symbol (emit var-name)) "=" (emit expr))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'defvar [type [defvar name expr]]
  (str (emit name) "=" (emit expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'let [type [let name expr]]
  (str "let " (emit name) "=" (emit expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'alias [type [alias name expr]]
  (str "alias " (emit name) "='" (emit expr) "'"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'str [type [str & args]]
  (apply clojure.core/str (map emit args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'quoted [type [quoted arg]]
  (add-quotes (emit arg)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'println [type [println & args]]
  (str "echo " (emit args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'print [type [println & args]]
  (str "echo -n " (emit args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'invoke
  [type [name & args]]
  (logging/trace (str "INVOKE " name args))
  (or (try
        (script/invoke-target name args)
        (catch java.lang.IllegalArgumentException e
          (throw (java.lang.IllegalArgumentException.
                  (str "Invalid arguments for " name) e))))
      (let [argseq (interpose " "
                     (filter (complement string/blank?) (map emit args)))]
        (apply str (emit name) (if (seq argseq) " " ) argseq))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn emit-method [obj method args]
  (str (emit obj) "." (emit method) (comma-list (map emit args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- emit-body-for-if [form]
  (if (or (compound-form? form)
          (= 'if (first form))
          (.contains (emit form) "\n"))
    (str \newline (string/trim (emit form)) \newline)
    (str " " (emit form) ";")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'if [type [if test true-form & false-form]]
  (str "if "
       (if (logical-test? test) (str "[ " (emit test) " ]") (emit test))
       "; then"
       (emit-body-for-if true-form)
       (when (first false-form)
         (str "else" (emit-body-for-if (first false-form))))
       "fi"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'if-not [type [if test true-form & false-form]]
  (str "if "
       (if (logical-test? test)
         (str "[ ! " (emit test) " ]")
         (str "! " (emit test)))
       "; then"
       (emit-body-for-if true-form)
       (when (first false-form)
         (str "else" (emit-body-for-if (first false-form))))
       "fi"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'case
  [type [case test & exprs]]
  (str "case " (emit test) " in\n"
       (string/join ";;\n"
        (map #(str (emit (first %)) ")\n" (emit (second %)))
             (partition 2 exprs)))
       ";;\nesac"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'dot-method [type [method obj & args]]
  (let [method (symbol (substring (str method) 1))]
    (emit-method obj method args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'return [type [return expr]]
  (str "return " (emit expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'set! [type [set! var val]]
  (str (check-symbol (emit var)) "=" (emit val)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'new [type [new class & args]]
  (str "new " (emit class) (comma-list (map emit args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'aget [type [aget var idx]]
  (str "${" (emit var) "[" (emit idx) "]}"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'get [type [get var-name idx]]
  (str "$(hash_echo "
       (munge-symbol (emit var-name)) " "
       (munge-symbol (emit idx))
       " -n )"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'aset [type [aget var idx val]]
  (str (emit var) "[" (emit idx) "]=" (emit val)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'merge! [type [merge! var-name expr]]
  (set-map-values var-name expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'assoc! [type [merge! var-name idx val]]
  (format
   "hash_set %s %s %s"
   (munge-symbol (emit var-name))
   (munge-symbol (emit idx))
   (emit val)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'deref
  [type [deref expr]]
  (if (instance? clojure.lang.IPersistentList expr)
    (str "$(" (emit expr) ")")
    (str "${" (emit expr) "}")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- emit-do [exprs]
  (string/join "" (map (comp statement emit) exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'do [type [ do & exprs]]
  (emit-do exprs))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'when [type [when test & form]]
  (str "if "
       (if (logical-test? test) (str "[ " (emit test) " ]") (emit test))
       "; then"
       (str \newline (string/trim (emit-do form)) \newline)
       "fi"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'while
  [type [ while test & exprs]]
  (str "while "
       (if (logical-test? test) (str "[ " (emit test) " ]") (emit test))
       "; do\n"
       (emit-do exprs)
       "done\n"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'doseq
  [type [ doseq [arg values] & exprs]]
  (str "for " (emit arg) " in " (string/join " " (map emit values))
       "; do\n"
       (emit-do exprs)
       "done"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'group
  [type [ group & exprs]]
  (str "{ " (string/join "; " (map emit exprs)) "; }"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'pipe
  [type [ pipe & exprs]]
  (string/join " | " (map emit exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'chain-or
  [type [chain-or & exprs]]
  (string/join " || " (map emit exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'chain-and
  [type [chain-and & exprs]]
  (string/join " && " (map emit exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- emit-function [name sig body]
  (assert (or (symbol? name) (nil? name)))
  (assert (vector? sig))
  (str "function " name "() {\n"
       (when (not (empty? sig))
         (str
          (string/join "\n" (map #(str (emit %1) "=" "$" %2) sig (iterate inc 1)))
          \newline))
       (emit-do body)
       " }\n"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'defn [type [fn & expr]]
  (if (symbol? (first expr))
    (let [name (first expr)
          signature (second expr)
          body (rest (rest expr))]
      (emit-function name signature body))
    (let [signature (first expr)
          body (rest expr)]
      (emit-function nil signature body))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn emit-s-expr [expr]
  (if (symbol? (first expr))
    (let [head (symbol (name (first expr)))  ; remove any ns resolution
          expr (conj (rest expr) head)]
      (cond
        (and (= (first (str head)) \.)
             (> (count (str head)) 1)) (emit-special 'dot-method expr)
        (special-form? head) (emit-special head expr)
        (infix-operator? head) (emit-infix head expr)
        :else (emit-special 'invoke expr)))
    (string/join " " (map emit expr))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.IPersistentList [expr]
  (emit-s-expr expr))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.Cons
  [expr]
  (if (= 'list (first expr))
    (emit-s-expr (rest expr))
    (emit-s-expr expr)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- spread
  [arglist]
  (cond
   (nil? arglist) nil
   (nil? (next arglist)) (seq (first arglist))
   :else (apply list (first arglist) (spread (next arglist)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit-special 'apply [type [apply & exprs]]
  (emit-s-expr (spread exprs)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.IPersistentVector [expr]
  (str "(" (string/join " " (map emit expr)) ")"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmethod emit clojure.lang.IPersistentMap [expr]
  (letfn [(subscript-assign
           [pair]
           (str "["(emit (key pair)) "]=" (emit (val pair))))]
    (str "(" (string/join " " (map subscript-assign (seq expr))) ")")))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn script* [forms]
  (let [code (if (> (count forms) 1)
               (emit-do forms)
               (emit (first forms)))]
    code))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- unquote?
  "Tests whether the form is (clj ...) or (unquote ...) or ~expr."
  [form]
  (or (and (seq? form)
           (symbol? (first form))
           (= (symbol (name (first form))) 'clj))
      (and (seq? form) (= (first form) `unquote))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- unquote-splicing?
  "Tests whether the form is ~@( ...) or (unqote-splicing ...)."
  [form]
  (and (seq? form) (= (first form) `unquote-splicing)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- handle-unquote [form]
  (second form))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- splice [form]
  (string/join " " (map emit form)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- handle-unquote-splicing [form]
  (list splice (second form)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(declare inner-walk outer-walk)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- inner-walk [form]
  (cond
   (unquote? form) (handle-unquote form)
   (unquote-splicing? form) (handle-unquote-splicing form)
   :else (walk/walk inner-walk outer-walk form)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- outer-walk [form]
  (cond
   (symbol? form) (list 'quote form)
   (seq? form) (list* 'list form)
   :else form))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro quasiquote
  [form]
  (let [post-form (walk/walk inner-walk outer-walk form)]
    post-form))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro script
  "Takes one or more forms. Returns a string of the forms translated into
   shell script.
       (script
         (println \"hello\")
         (ls -l \"*.sh\"))"
  [& forms]
  `(script/with-line-number [~*file* ~(:line (meta &form))]
     (script* (quasiquote ~forms))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro defimpl
  "Define a script function implementation for the given `specialisers`.

   `specialisers` should be the :default keyword, or a vector.  The
   `specialisers` vector may contain keywords, a set of keywords that provide an
   inclusive `or` match, or functions that return a truth value indication
   whether the implementation is a match for the script template passed as the
   function's first argument.

   `body` is wrapped in an implicit `script` form.

       (pallet.script/defscript ls [& args])
       (defimpl ls :default [& args] (ls ~@args))
       (defimpl ls [:windows] [& args] (dir ~@args))"
  [script-name specialisers [& args] & body]
  {:pre [(or (= :default specialisers)
             (vector? specialisers))]}
  `(pallet.script/implement
    ~(name script-name) ~specialisers
    (fn ~(symbol (str "script-fn-for-" (name script-name))) [~@args]
      (script ~@body))))</pre></tr><tr><td class="docs"><p>Concatenate multiple scripts.</p>

<p>Script combiners</p>
</td><td class="codes" /><pre class="brush: clojure">(defn do-script*
  [scripts]
  (str
   (string/join \newline
     (filter
      (complement string/blank?)
      (map #(when % (string/trim %)) scripts)))
   \newline))</pre></tr><tr><td class="docs"><p>Concatenate multiple scripts.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn do-script
  [& scripts]
  (do-script* scripts))</pre></tr><tr><td class="docs"><p>Chain commands together with &amp;&amp;.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn chain-commands*
  [scripts]
  (string/join " && "
    (filter
     (complement string/blank?)
     (map #(when % (string/trim %)) scripts))))</pre></tr><tr><td class="docs"><p>Chain commands together with &amp;&amp;.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn chain-commands
  [& scripts]
  (chain-commands* scripts))</pre></tr><tr><td class="docs"><p>Wrap a command in a code that checks the return value. Code to output the
  messages is added before the command.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn checked-commands*
  [message cmds]
  (let [chained-cmds (chain-commands* cmds)]
    (if (string/blank? chained-cmds)
      ""
      (str
        "echo \"" message "...\"" \newline
        "{ " chained-cmds "; } || { echo \"" message "\" failed; exit 1; } >&2 "
        \newline
        "echo \"...done\"\n"))))</pre></tr><tr><td class="docs"><p>Wrap a command in a code that checks the return value. Code to output the
  messages is added before the command.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn checked-commands
  [message & cmds]
  (checked-commands* message cmds))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro chained-script
  "Takes one or more forms. Returns a string of the forms translated into a
   chained shell script command."
  [& forms]
  `(chain-commands
    ~@(map (fn [f] (list `script f)) forms)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro checked-script
  "Takes one or more forms. Returns a string of the forms translated into
   shell scrip.  Wraps the expression in a test for the result status."
  [message & forms]
  `(checked-commands ~message
    ~@(map (fn [f] (list `script f)) forms)))</pre></tr><tr><td class="docs"><p>script argument helpers</p>
</td><td class="codes" /><pre class="brush: clojure">(defn arg-string
  [option argument do-underscore do-assign dash]
  (let [opt (if do-underscore (utils/underscore (name option)) (name option))]
    (if argument
      (if (> (.length opt) 1)
        (str dash opt (if-not (= argument true)
                        (str (if do-assign "=" " ") argument)))
        (str "-" opt (if-not (= argument true) (str " " argument)))))))</pre></tr><tr><td class="docs"><p>Output a set of command line switches from a map</p>
</td><td class="codes" /><pre class="brush: clojure">(defn map-to-arg-string
  [m & options]
  (let [opts (apply hash-map options)]
    (apply
     str (interpose
          " "
          (map #(arg-string
                 (first %) (second %) (opts :underscore) (:opts :assign)
                 (get opts :dash "--"))
               m)))))</pre></tr><tr><td class="docs"><p>Output a set of command line switches from a sequence of options</p>
</td><td class="codes" /><pre class="brush: clojure">(defn option-args
  [options]
  (let [m (if (first options) (apply hash-map options) {})
        assign (m :assign)
        underscore (m :underscore)]
    (map-to-arg-string
     (dissoc m :assign :underscore) :assign assign :underscore underscore)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.strint" name="pallet.strint"><h1 class="project-name">pallet.strint</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Runtime string interpolation built on top of clojure.contrib.strint.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.strint
 (:use clojure.contrib.strint)
 (:require
   clojure.walk))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro capture-values
  "Capture the values of the specified symbols in a symbol->value map."
  [& values]
  (into {} (map (fn [s] [ `'~s s]) values)))</pre></tr><tr><td class="docs"><p>Interpolate a string given a map of symbol->value</p>
</td><td class="codes" /><pre class="brush: clojure">(defn <<!
  [f value-map]
  (apply str
         (map (fn [x] (if (symbol? x)
                            (value-map x)
                            (if (seq x)
                              (eval (clojure.walk/prewalk-replace value-map x))
                              x)))
                  (#'clojure.contrib.strint/interpolate f))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.target" name="pallet.target"><h1 class="project-name">pallet.target</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provide information about the target image</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.target
  (:require
   [clojure.contrib.condition :as condition]))</pre></tr><tr><td class="docs"><p>OS family</p>
</td><td class="codes" /><pre class="brush: clojure">(defn os-family
  [target] (:os-family target))</pre></tr><tr><td class="docs"><p>Default administrator group</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-group
  [target]
  (case (os-family target)
    :yum "wheel"
    "adm"))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.containers" name="pallet.task.containers"><h1 class="project-name">pallet.task.containers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>List contianers.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.containers
  (:require
   [pallet.blobstore :as blobstore]))</pre></tr><tr><td class="docs"><p>List containers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn containers
  [request & args]
  (doseq [container (blobstore/containers (:blobstore request))
          :let [container (bean container)
                location (-> container :location)]]
    (println
     (format
      "\t%20s  %s"
      (:name container) (.getDescription location)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.converge" name="pallet.task.converge"><h1 class="project-name">pallet.task.converge</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.converge
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (not (keyword? a)) (recur
                           (nnext args)
                           prefix
                           (assoc (or m {}) a (fnext args))
                           phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat [m] (if prefix [:prefix prefix] []) [:phase phases]))))</pre></tr><tr><td class="docs"><p>Adjust node counts.  Requires a map of node-type, count pairs.
     eg. pallet converge mynodes/my-node 1
   The node-types should be namespace qualified.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn converge
  [request & args]
  (let [args (build-args args)]
    (apply core/converge (concat args (apply concat request)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.describe-node" name="pallet.task.describe-node"><h1 class="project-name">pallet.task.describe-node</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Adjust node counts.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.describe-node
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs"><p>Display the node definition for the given node-types.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn describe-node
  {:no-service-required true}
  [& args]
  (doseq [arg args]
    (println (format "%s\t %s" (arg :tag) (arg :image)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.feedback" name="pallet.task.feedback"><h1 class="project-name">pallet.task.feedback</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Feedback to the pallet project.
      add  - send new feedback. Arguments will be sent as text.
      list - show recent feedback.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.feedback
  (:require
   [pallet.heynote :as heynote]
   [clojure.contrib.http.agent :as agent]
   [clojure.contrib.http.connection :as connection]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def heynote-project (heynote/project "pallet"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def desc "feedback")
(defn as-keyword [x]
  (cond
   (string? x) (keyword x)
   (symbol? x) (keyword (name x))
   :else x))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn feedback
  {:no-service-required true}
  [& args]
  (let [[task & args] args
        task (as-keyword task)
        task (or task :list)]
    (condp = task
        :add  (heynote/new-item
               :text (apply str (interpose " " args)))
        :list (heynote/items)
        :show (if-let [item (first args)]
                (heynote/item item)
                (println "Specify the %tag to show."))
        :comment (let [[item & args] args]
                   (if item
                     (heynote/add-comment
                      item
                      :text (apply str (interpose " " args)))
                     (println "Specify the %tag to comment on.")))
        (do (println "Unknown feedback command" task)
            (println "Valid feedback commands:")
            (println "  list         - list feedback")
            (println "  add          - add a feedback (%tag to name it)")
            (println "  comment %tag - add a comment on the specified item")
            (println "  show %tag    - show the specified item")))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.help" name="pallet.task.help"><h1 class="project-name">pallet.task.help</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Display a list of tasks or help for a given task.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.help)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(def impl-ns #"^pallet\.task\.")
(def task-list (atom nil))</pre></tr><tr><td class="docs"><p>Find the available tasks.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tasks
  []
  (try
   (require 'clojure.contrib.find-namespaces)
   (let [find-namespaces-on-classpath
         (find-var 'clojure.contrib.find-namespaces/find-namespaces-on-classpath)]
     (or @task-list
         (reset! task-list
                 (set (filter #(re-find impl-ns (name %))
                              (find-namespaces-on-classpath))))))
   (catch java.io.FileNotFoundException e
     #{'pallet.task.help
       'pallet.task.new-project})))</pre></tr><tr><td class="docs"><p>Help for a task is stored in its docstring, or if that's not present
  in its namespace.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn help-for
  [task]
  (let [task-ns (symbol (str "pallet.task." task))
        _ (require task-ns)
        task (ns-resolve task-ns (symbol task))]
    (or (:doc (meta task))
        (:doc (meta (find-ns task-ns))))))</pre></tr><tr><td class="docs"><p>affected by clojure ticket #130: bug of AOT'd namespaces losing metadata</p>
</td><td class="codes" /><pre class="brush: clojure">(defn help-summary-for [task-ns]
  (require task-ns)
  (let [task-name (last (.split (name task-ns) "\\."))]
    (str task-name (apply str (repeat (- 8 (count task-name)) " "))
         " - " (:doc (meta (find-ns task-ns))))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn help
  {:no-service-required true}
  ([task] (println (help-for task)))
  ([]
     (println "Pallet is a cloud administration tool.\n")
     (println "Several tasks are available:")
     (doseq [task-ns (tasks)]
       ;; (println (help-summary-for task-ns))
       (println " " (last (.split (name task-ns) "\\."))))
     (println "\nRun pallet help $TASK for details.")
     (if @task-list
       (do
         (println "\nYou can write project specific tasks under the\n"
                  "pallet.task namespace.")
         (println "\nOptions:")
         (println "  -service name-of-cloud-service")
         (println "  -user    login for cloud service API")
         (println "  -key     key or password for cloud service API")
         (println "\nIf no options are given, the following sequence is used to")
         (println "find a service to use.")
         (println "\n  the pallet.config.service property is checked for the")
         (println "    name of a var to use for the service,")
         (println "\n  the ~/.pallet/config.clj is checked for an active profile")
         (println "    specified with `defpallet`.  e.g.")
         (println "      (defpallet")
         (println "        :providers {")
         (println "          :aws {:provider \"ec2\)
         (println "                :identity \"username or key\)
         (println "                :credential \"password, key or secret key\"}})")
         (println "\n  the ~/.m2/settings.xml is checked for an active profile")
         (println "    with the following properties:")
         (println "      pallet.compute.provider")
         (println "      pallet.compute.identity")
         (println "      pallet.compute.credential,")
         (println "\n  the pallet.config/service is used if it exists."))
       (do
         (println "Run the new-project task to create a pallet project.\n")))
     (println "\nSee http://github.com/hugoduncan/pallet.")))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.lift" name="pallet.task.lift"><h1 class="project-name">pallet.task.lift</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Apply configuration.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.lift
  (:require
   [pallet.core :as core]
   [clojure.contrib.logging :as logging]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- build-args [args]
  (loop [args args
         prefix nil
         m nil
         phases []]
    (if-let [a (first args)]
      (cond
       (and (nil? m) (symbol? a) (nil? (namespace a))) (recur
                                                        (next args)
                                                        (name a)
                                                        m
                                                        phases)
       (not (keyword? a)) (recur
                           (next args)
                           prefix
                           (conj (or m []) a)
                           phases)
       :else (recur (next args) prefix m (conj phases a)))
      (concat (if prefix [prefix] []) [(set m)] [:phase phases]))))</pre></tr><tr><td class="docs"><p>Apply configuration.
     eg. pallet lift mynodes/my-node
   The node-types should be namespace qualified.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn lift
  [request & args]
  (let [args (build-args args)]
    (apply core/lift (concat args (apply concat request)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.new-project" name="pallet.task.new-project"><h1 class="project-name">pallet.task.new-project</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Create a new pallet project.
     pallet new-project <project-directory>.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.new-project
  (:import
   [java.io
    File OutputStreamWriter FileOutputStream PrintWriter]))</pre></tr><tr><td class="docs"><p>We don't want this task to depend on clojure.contrib, or on lein</p>
</td><td class="codes" /></tr><tr><td class="docs"><p>(defn spit
"Opposite of slurp.  Opens f, writes content, then closes f."
[f content]
(with-open [w (PrintWriter.
(OutputStreamWriter.
(FileOutputStream. f)))]
(.print w content)))</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn file
  [& args]
  (File. (apply str (interpose "/" args))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn ns->path [n]
  (str (.. (str n)
           (replace \- \_)
           (replace \. \/))
       ".clj"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn new-project-lein
  [project-name project-dir]
  (let [project-name (symbol project-name)
        group-id (namespace project-name)
        artifact-id (name project-name)]
    (.mkdirs (File. project-dir))
    (spit (file project-dir "project.clj")
          (str "(defproject " project-name " \"1.0.0-SNAPSHOT\"\n"
               "  :description \"FIXME: write\"\n"
               "  :dependencies [[pallet/pallet \"0.0.1-SNAPSHOT\"]])\n"))
    (let [project-ns  (str (.replace (str project-name) "/" ".") ".nodes")
          project-clj (ns->path project-ns)
          test-clj (.replace project-clj ".clj" "_test.clj")]
      (.mkdirs (file project-dir "test"))
      (.mkdirs (.getParentFile (file project-dir "src" project-clj)))
      (spit (file project-dir "src" project-clj)
            (str "(ns " project-ns
                 "\n  \"Admin and provisioning for FIXME:project.\" "
                 "\n  (:require"
                 "\n    [pallet.core :as core]))\n"))
      (.mkdirs (.getParentFile (file project-dir "test" test-clj)))
      (spit (file project-dir "test" test-clj)
            (str "(ns " (str project-ns "-test")
                 "\n  (:use [" project-ns "] :reload-all)"
                 "\n  (:use [clojure.test]))\n\n"
                 "(deftest replace-me ;; FIXME: write\n  (is false))\n"))
      (spit (file project-dir ".gitignore")
            (apply str (interpose"\n" ["pom.xml" "*jar" "lib" "classes"])))
      (spit (file project-dir "README")
            (apply str (interpose "\n\n" [(str "# " artifact-id)
                                          "FIXME: write description"
                                          "## Usage" "FIXME: write"
                                          "## Installation" "FIXME: write"
                                          "## License" "FIXME: write\n"])))
      (println "Created new project in:" project-dir)
      (println "You should now run 'lein deps' in that directory."))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn new-project
  {:no-service-required true}
  [& args]
  (let [name (first args)
        dir (or (second args) "pallet")]
    (if (.exists (File. dir))
      (do
        (println "Directory" dir "already exists.")
        (System/exit 1))
      (new-project-lein name dir))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.nodes" name="pallet.task.nodes"><h1 class="project-name">pallet.task.nodes</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>list nodes.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.nodes
  (:require
   [pallet.compute :as compute]
   [clojure.contrib.pprint :as pprint])
  (:use clojure.contrib.logging))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn nodes
  [request]
  (let [ns (compute/nodes (:compute request))]
    (doseq [n ns]
      (println n))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.providers" name="pallet.task.providers"><h1 class="project-name">pallet.task.providers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.providers
  (:require
   [pallet.utils :as utils]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- provider-properties []
  (apply
   hash-map
   (apply concat
          (filter #(re-find #"(.*)\.contextbuilder" (first %))
                  (utils/resource-properties "rest.properties")))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- enabled?
  [provider]
  (try
   (Class/forName provider)
   (catch java.lang.ClassNotFoundException e)))</pre></tr><tr><td class="docs"><p>Provide information on the supported and enabled providers.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn providers
  {:no-service-required true}
  [& _]
  (println "Pallet uses jcloud's providers.\n")
  (doseq [supported (sort #(compare (first %1) (first %2))
                          (provider-properties))
          :let [key (first supported)
                name (.substring key 0 (.indexOf key "."))]]
    (println
     (format
      "\t%20s  %s"
      name
      (if (enabled? (second supported)) "Enabled" "Disabled"))))
  (println "\nProviders can be enabled by copying the corresponding jclouds jar")
  (println "into pallet/lib."))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.to-blob" name="pallet.task.to-blob"><h1 class="project-name">pallet.task.to-blob</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Upload to a blob.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.to-blob
  (:require
   [pallet.blobstore :as blobstore]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn war-file-name
  [project]
  (format "%s-%s.war" (:name project) (:version project)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn find-war
  [project]
  (some
   #(let [f (% project)] (and (.exists (java.io.File. f)) f))
   [war-file-name]))</pre></tr><tr><td class="docs"><p>Upload to a blob.
    to-blob container path filename
   By default tries to upload the project war file.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn to-blob
  [request & args]
  (let [[container path & files] (map name args)
        file (or (first files) (find-war (:project request)))
        options (-> request :project :pallet)]
    (if file
      (do
        (println "Uploading" file)
        (blobstore/put-file (:blobstore request) container path file))
      (println "Nothing to upload"))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.task.version" name="pallet.task.version"><h1 class="project-name">pallet.task.version</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Print Pallet's version to standard out.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.task.version)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn version
  {:no-service-required true}
  []
  (println "Pallet" (System/getProperty "pallet.version")
           "on Java" (System/getProperty "java.version")
           (System/getProperty "java.vm.name")))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template.properties" name="pallet.template.properties"><h1 class="project-name">pallet.template.properties</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>A template for writing properties style config files.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.template.properties
  (:use [pallet.utils :only [as-string]]))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn property-section [[name settings]]
  (apply
   str
   "[" (as-string name) "]" \newline
   (map #(format "%s = %s\n" (as-string (first %)) (as-string (second %))) settings)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn property-set [p]
  (apply str (map property-section p)))</pre></tr><tr><td class="docs"><p>Write a properties file based on the input argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn properties
  [values]
  (apply str (map property-set values)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.template" name="pallet.template"><h1 class="project-name">pallet.template</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Template file writing</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.template
  (:require
   [pallet.strint :as strint]
   [pallet.target :as target]
   [pallet.compute :as compute]
   [pallet.utils :as utils]
   [clojure.string :as string]
   [pallet.stevedore :as stevedore])
  (:use
   [pallet.resource.file]
   [clojure.contrib.logging]))</pre></tr><tr><td class="docs"><p>Loads a resource. Returns a URI.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn get-resource
  [path]
  (-> (clojure.lang.RT/baseLoader) (.getResource path)))</pre></tr><tr><td class="docs"><p>Split a resource path into path, basename and extension components.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn path-components
  [path]
  (let [p (inc (.lastIndexOf path "/"))
        i (.lastIndexOf path ".")]
    [(when (pos? p) (subs path 0 (dec p)))
     (if (neg? i) (subs path p) (subs path p i))
     (if (neg? i) nil (subs path (inc i)))]))</pre></tr><tr><td class="docs"><p>Build a pathname from a list of path and filename parts.  Last part is
   assumed to be a file extension.</p>

<p>   'The name of a resource is a '/'-separated path name that identifies the
   resource.'</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pathname
  [path file ext]
  (str (when path (str path "/")) file (when ext (str "." ext))))</pre></tr><tr><td class="docs"><p>Generate a prioritised list of possible template paths.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn candidate-templates
  [path tag template]
  (let [[dirpath base ext] (path-components path)
        variants (fn [specifier]
                   (let [p (pathname
                            dirpath
                            (if specifier (str base "_" specifier) base)
                            ext)]
                     [p (str "resources/" p)]))]
    (concat
     (variants tag)
     (variants (name (or (target/os-family template) "unknown")))
     (variants (name (or (compute/packager template) "unknown")))
     (variants nil))))</pre></tr><tr><td class="docs"><p>Find a template for the specified path, for application to the given node.
   Templates may be specialised.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-template
  [path node-type]
  {:pre [(map? node-type) (:image node-type)]}
  (some
   get-resource
   (candidate-templates path (:tag node-type) (:image node-type))))</pre></tr><tr><td class="docs"><p>Interpolate the given template.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn interpolate-template
  [path values node-type]
  (strint/<<!
   (utils/load-resource-url
    (find-template path node-type))
   (utils/map-with-keys-as-symbols values)))</pre></tr><tr><td class="docs"><p>programatic templates - umm not really templates at all</p>
</td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro deftemplate [template [& args] m]
  `(defn ~template [~@args]
     ~m))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn- apply-template-file [[file-spec content]]
  (trace (str "apply-template-file " file-spec \newline content))
  (let [path (:path file-spec)]
    (string/join ""
                 (filter (complement nil?)
                         [(stevedore/script (var file ~path) (cat > @file <<EOF))
                          content
                          "\nEOF\n"
                          (when-let [mode (:mode file-spec)]
                            (stevedore/script (do ("chmod" ~mode @file))))
                          (when-let [group (:group file-spec)]
                            (stevedore/script (do ("chgrp" ~group @file))))
                          (when-let [owner (:owner file-spec)]
                            (stevedore/script (do ("chown" ~owner @file))))]))))</pre></tr><tr><td class="docs"><p>TODO - add chmod, owner, group</p>
</td><td class="codes" /><pre class="brush: clojure">(defn apply-templates [template-fn args]
  (string/join  (map apply-template-file (apply template-fn args))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.thread-expr" name="pallet.thread-expr"><h1 class="project-name">pallet.thread-expr</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Macros that can be used in an expression thread</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.thread-expr)</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro for->
  "Apply a thread expression to a sequence.
   eg.
      (-> 1
        (for-> [x [1 2 3]]
          (+ x)))
   => 7"
  [arg [value s & {:keys [let]}] & body]
  (clojure.core/let
   [argsym (gensym "arg")]
   `(let [arg# ~arg s# ~s] ; maintain correct evaluation order
      (reduce
       (fn [~argsym ~value]
         ~(if let
            `(let ~let
               (-> ~argsym ~@body))
            `(-> ~argsym ~@body)))
       arg#
       s#))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro when->
  "A `when` form that can appear in a request thread.
   eg.
      (-> 1
        (when-> true
          (+ 1)))
   => 2"
  [arg condition & body]
  `(let [arg# ~arg]
     (if ~condition
       (-> arg# ~@body)
       arg#)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro when-not->
  "A `when-not` form that can appear in a request thread.
   eg.
      (-> 1
        (when-not-> true
          (+ 1)))
   => 2"
  [arg condition & body]
  `(let [arg# ~arg]
     (if-not ~condition
       (-> arg# ~@body)
       arg#)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro when-let->
  "A `when-let` form that can appear in a request thread.
   eg.
      (-> 1
        (when-let-> [a 1]
          (+ a)))
   => 2"
  [arg binding & body]
  `(let [arg# ~arg]
     (if-let ~binding
       (-> arg# ~@body)
       arg#)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro if->
  "An `if` form that can appear in a request thread
   eg.
      (-> 1
        (if-> true
          (+ 1)
          (+ 2)))
   => 2"
  ([arg condition form]
     `(let [arg# ~arg]
        (if ~condition
          (-> arg# ~form)
          arg#)))
  ([arg condition form else-form ]
     `(let [arg# ~arg]
        (if ~condition
          (-> arg# ~form)
          (-> arg# ~else-form)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro if-not->
  "An `if-not` form that can appear in a request thread
   eg.
      (-> 1
        (if-not-> true
          (+ 1)
          (+ 2)))
   => 3"
  ([arg condition form]
     `(let [arg# ~arg]
        (if-not ~condition
          (-> arg# ~form))))
  ([arg condition form else-form ]
     `(let [arg# ~arg]
        (if-not ~condition
          (-> arg# ~form)
          (-> arg# ~else-form)))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro let-with-arg->
  "A `let` form that can appear in a request thread, and assign the value of the
   threaded arg.
   eg.
      (-> 1
        (let-with-arg-> val [a 1]
          (+ a val)))
   => 3"
  [arg arg-symbol binding & body]
  `(let [~arg-symbol ~arg]
     (let ~binding
       (-> ~arg-symbol ~@body))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro apply->
  "Apply in a threaded expression.
   e.g.
      (-> 1
        (apply-> + [1 2 3]))
   => 7"
  [request f & args]
  `(let [request# ~request]
     (apply ~f request# ~@args)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro apply-map->
  "Apply in a threaded expression.
   e.g.
      (-> :a
        (apply-map-> hash-map 1 {:b 2}))
   => {:a 1 :b 2}"
  [request f & args]
  `(let [request# ~request]
     (apply ~f request# ~@(butlast args) (apply concat ~(last args)))))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#pallet.utils" name="pallet.utils"><h1 class="project-name">pallet.utils</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs"><p>Utilities used across pallet.</p>
</td><td class="codes" /><pre class="brush: clojure">(ns pallet.utils
  (:require
   [clojure.contrib.io :as io]
   [clojure.contrib.string :as string]
   [clojure.contrib.pprint :as pprint]
   [clojure.contrib.logging :as logging])
  (:use
   clojure.contrib.logging
   clj-ssh.ssh
   clojure.contrib.def))</pre></tr><tr><td class="docs"><p>Pretty print a multiline string</p>
</td><td class="codes" /><pre class="brush: clojure">(defn pprint-lines
  [s]
  (pprint/pprint (seq (.split #"\r?\n" s))))</pre></tr><tr><td class="docs"><p>Return the string value of the argument in quotes.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn quoted
  [s]
  (str "\"" s "\""))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn underscore [s]
  "Change - to _"
  (apply str (interpose "_"  (.split s "-"))))</pre></tr><tr><td class="docs"><p>Return the string value of the argument.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn as-string
  [arg]
  (cond
   (symbol? arg) (name arg)
   (keyword? arg) (name arg)
   :else (str arg)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn resource-path [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        resource (. loader getResource name)]
    (when resource
      (.getFile resource))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn load-resource
  [name]
  (let [loader (.getContextClassLoader (Thread/currentThread))]
    (.getResourceAsStream loader name)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn load-resource-url
  [name]
  (logging/trace (format "load-resource-url %s" name))
  (with-open [stream (.getContent name)
              r (new java.io.BufferedReader
                     (new java.io.InputStreamReader
                          stream (.name (java.nio.charset.Charset/defaultCharset))))]
    (let [sb (new StringBuilder)]
      (loop [c (.read r)]
        (if (neg? c)
          (str sb)
          (do
            (.append sb (char c))
            (recur (.read r))))))))</pre></tr><tr><td class="docs"><p>Reads the resource named by name using the encoding enc into a string
   and returns it.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn slurp-resource
  ([name] (slurp-resource
           name (.name (java.nio.charset.Charset/defaultCharset))))
  ([#^String name #^String enc]
     (let [stream (load-resource name)]
       (when stream
         (with-open [stream stream
                     r (new java.io.BufferedReader
                            (new java.io.InputStreamReader
                                 stream enc))]
           (let [sb (new StringBuilder)]
             (loop [c (.read r)]
               (if (neg? c)
                 (str sb)
                 (do
                   (.append sb (char c))
                   (recur (.read r)))))))))))</pre></tr><tr><td class="docs"><p>Given a resource <code>path</code>, load it as a java properties file.
   Returns nil if resource not found.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn resource-properties
  [path]
  (let [loader (.getContextClassLoader (Thread/currentThread))
        stream (.getResourceAsStream loader path)]
    (when stream
      (with-open [stream stream]
        (let [properties (new java.util.Properties)]
          (.load properties stream)
          (let [keysseq (enumeration-seq (. properties propertyNames))]
            (reduce (fn [a b] (assoc a b (. properties getProperty b)))
                    {} keysseq)))))))</pre></tr><tr><td class="docs"><p>Read the given file as a byte array.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn slurp-as-byte-array
  [#^java.io.File file]
  (let [size (.length file)
        bytes #^bytes (byte-array size)
        stream (new java.io.FileInputStream file)]
    bytes))</pre></tr><tr><td class="docs"><p>Find the var for the given namespace and symbol. If the namespace does
   not exist, then it will be required.
       (find-var-with-require 'my.ns 'a-symbol)
       (find-var-with-require 'my.ns/a-symbol)</p>
</td><td class="codes" /><pre class="brush: clojure">(defn find-var-with-require
  ([sym]
     (find-var-with-require (symbol (namespace sym)) (symbol (name sym))))
  ([ns sym]
     (try
       (when-not (find-ns ns)
         (require ns))
       (when-let [v (ns-resolve ns sym)]
         (var-get v))
       (catch Exception _))))</pre></tr><tr><td class="docs"><p>Return the default private key path.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-private-key-path
  []
  (str (System/getProperty "user.home") "/.ssh/id_rsa"))</pre></tr><tr><td class="docs"><p>Return the default public key path</p>
</td><td class="codes" /><pre class="brush: clojure">(defn default-public-key-path
  []
  (str (System/getProperty "user.home") "/.ssh/id_rsa.pub"))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defrecord User
  [username public-key-path private-key-path passphrase
   password sudo-password no-sudo])</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defn user? [user]
  (instance? pallet.utils.User user))</pre></tr><tr><td class="docs"><p>Creates a User record with the given username and options. Generally used
   in conjunction with <em>admin-user</em> and pallet.core/with-admin-user, or passed
   to <code>lift</code> or <code>converge</code> as the named :user argument.</p>

<p>   Options:
    - :public-key-path (defaults to ~/.ssh/id_rsa.pub)
    - :private-key-path (defaults to ~/.ssh/id_rsa)
    - :passphrase
    - :password
    - :sudo-password (defaults to :password)
    - :no-sudo</p>
</td><td class="codes" /><pre class="brush: clojure">(defn make-user
  [username & {:keys [public-key-path private-key-path passphrase
                      password sudo-password no-sudo] :as options}]
  (merge (User. username nil nil nil nil nil nil)
    {:private-key-path (default-private-key-path)
     :public-key-path (default-public-key-path)
     :sudo-password (:password options)}
    options))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defvar *admin-user*
  (make-user (or (. System getProperty "pallet.admin.username")
                 (. System getProperty "user.name")))
  "The admin user is used for running remote admin commands that require root
   permissions.  The default admin user is taken from the pallet.admin.username
   property.  If not specified then the user.name property is used.
   The admin user can also be specified in config.clj when running tasks
   from the command line.")</pre></tr><tr><td class="docs"><p>Set the admin user based on pallet.config setup.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user-from-config-var
  []
  (find-var-with-require 'pallet.config 'admin-user))</pre></tr><tr><td class="docs"><p>Set the admin user based on a config map</p>
</td><td class="codes" /><pre class="brush: clojure">(defn admin-user-from-config
  [config]
  (when-let [admin-user (:admin-user config)]
    (apply make-user (:username admin-user) (apply concat admin-user))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-temp-file
  "Create a block where `varname` is a temporary `File` containing `content`."
  [[varname content] & body]
  `(let [~varname (java.io.File/createTempFile "stevedore", ".tmp")]
     (io/copy ~content ~varname)
     (let [rv# (do ~@body)]
       (.delete ~varname)
       rv#)))</pre></tr><tr><td class="docs"><p>Create a temporary file</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tmpfile
  ([] (java.io.File/createTempFile "pallet_" "tmp"))
  ([^java.io.File dir] (java.io.File/createTempFile "pallet_" "tmp" dir)))</pre></tr><tr><td class="docs"><p>Create a temporary directory.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn tmpdir
  []
  (doto (java.io.File/createTempFile "pallet_" "tmp")
    (.delete) ; this is a potential cause of non-unique names
    (.mkdir)))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro with-temporary
  "A block scope allowing multiple bindings to expressions.  Each binding will
   have the member function `delete` called on it."
  [bindings & body] {:pre
   [(vector?  bindings)
         (even? (count bindings))]}
  (cond
   (= (count bindings) 0) `(do ~@body)
   (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)
                             (try
                              (with-temporary ~(subvec bindings 2) ~@body)
                              (finally
                               (. ~(bindings 0) delete))))
   :else (throw (IllegalArgumentException.
                 "with-temporary only allows Symbols in bindings"))))</pre></tr><tr><td class="docs"><p>Produce a map that is the same as m, but with all keys are converted to
  symbols.</p>
</td><td class="codes" /><pre class="brush: clojure">(defn map-with-keys-as-symbols
  [m]
  (letfn [(to-symbol [x]
                     (cond
                      (symbol? x) x
                      (string? x) (symbol x)
                      (keyword? x) (symbol (name x))))]
    (zipmap (map to-symbol (keys m)) (vals m))))</pre></tr><tr><td class="docs">
</td><td class="codes" /><pre class="brush: clojure">(defmacro pipe
  "Build a request processing pipeline from the specified forms."
  [& forms]
  (let [[middlewares etc] (split-with #(or (seq? %) (symbol? %)) forms)
        middlewares (reverse middlewares)
        [middlewares [x :as etc]]
          (if (seq etc)
            [middlewares etc]
            [(rest middlewares) (list (first middlewares))])
          handler x]
    (if (seq middlewares)
      `(-> ~handler ~@middlewares)
      handler)))</pre></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a><div id="floating-toc"><ul><li class="floating-toc-li" id="floating-toc_pallet.argument">pallet.argument</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.implementation">pallet.blobstore.implementation</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.jclouds">pallet.blobstore.jclouds</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore.url-blobstore">pallet.blobstore.url-blobstore</li><li class="floating-toc-li" id="floating-toc_pallet.blobstore">pallet.blobstore</li><li class="floating-toc-li" id="floating-toc_pallet.command-line">pallet.command-line</li><li class="floating-toc-li" id="floating-toc_pallet.command-script">pallet.command-script</li><li class="floating-toc-li" id="floating-toc_pallet.compute.implementation">pallet.compute.implementation</li><li class="floating-toc-li" id="floating-toc_pallet.compute.jclouds">pallet.compute.jclouds</li><li class="floating-toc-li" id="floating-toc_pallet.compute.jvm">pallet.compute.jvm</li><li class="floating-toc-li" id="floating-toc_pallet.compute.node-list">pallet.compute.node-list</li><li class="floating-toc-li" id="floating-toc_pallet.compute.vmfest">pallet.compute.vmfest</li><li class="floating-toc-li" id="floating-toc_pallet.compute">pallet.compute</li><li class="floating-toc-li" id="floating-toc_pallet.configure">pallet.configure</li><li class="floating-toc-li" id="floating-toc_pallet.core">pallet.core</li><li class="floating-toc-li" id="floating-toc_pallet.debug">pallet.debug</li><li class="floating-toc-li" id="floating-toc_pallet.enlive">pallet.enlive</li><li class="floating-toc-li" id="floating-toc_pallet.execute">pallet.execute</li><li class="floating-toc-li" id="floating-toc_pallet.heynote">pallet.heynote</li><li class="floating-toc-li" id="floating-toc_pallet.main">pallet.main</li><li class="floating-toc-li" id="floating-toc_pallet.main-invoker">pallet.main-invoker</li><li class="floating-toc-li" id="floating-toc_pallet.maven">pallet.maven</li><li class="floating-toc-li" id="floating-toc_pallet.md5crypt">pallet.md5crypt</li><li class="floating-toc-li" id="floating-toc_pallet.parameter">pallet.parameter</li><li class="floating-toc-li" id="floating-toc_pallet.repl">pallet.repl</li><li class="floating-toc-li" id="floating-toc_pallet.request-map">pallet.request-map</li><li class="floating-toc-li" id="floating-toc_pallet.resource.directory">pallet.resource.directory</li><li class="floating-toc-li" id="floating-toc_pallet.resource.exec-script">pallet.resource.exec-script</li><li class="floating-toc-li" id="floating-toc_pallet.resource.file">pallet.resource.file</li><li class="floating-toc-li" id="floating-toc_pallet.resource.filesystem">pallet.resource.filesystem</li><li class="floating-toc-li" id="floating-toc_pallet.resource.filesystem-layout">pallet.resource.filesystem-layout</li><li class="floating-toc-li" id="floating-toc_pallet.resource.format">pallet.resource.format</li><li class="floating-toc-li" id="floating-toc_pallet.resource.hostinfo">pallet.resource.hostinfo</li><li class="floating-toc-li" id="floating-toc_pallet.resource.lib">pallet.resource.lib</li><li class="floating-toc-li" id="floating-toc_pallet.resource.network-service">pallet.resource.network-service</li><li class="floating-toc-li" id="floating-toc_pallet.resource.package">pallet.resource.package</li><li class="floating-toc-li" id="floating-toc_pallet.resource.remote-directory">pallet.resource.remote-directory</li><li class="floating-toc-li" id="floating-toc_pallet.resource.remote-file">pallet.resource.remote-file</li><li class="floating-toc-li" id="floating-toc_pallet.resource.resource-when">pallet.resource.resource-when</li><li class="floating-toc-li" id="floating-toc_pallet.resource.rsync">pallet.resource.rsync</li><li class="floating-toc-li" id="floating-toc_pallet.resource.service">pallet.resource.service</li><li class="floating-toc-li" id="floating-toc_pallet.resource.user">pallet.resource.user</li><li class="floating-toc-li" id="floating-toc_pallet.resource">pallet.resource</li><li class="floating-toc-li" id="floating-toc_pallet.resource-build">pallet.resource-build</li><li class="floating-toc-li" id="floating-toc_pallet.script">pallet.script</li><li class="floating-toc-li" id="floating-toc_pallet.stevedore">pallet.stevedore</li><li class="floating-toc-li" id="floating-toc_pallet.strint">pallet.strint</li><li class="floating-toc-li" id="floating-toc_pallet.target">pallet.target</li><li class="floating-toc-li" id="floating-toc_pallet.task.containers">pallet.task.containers</li><li class="floating-toc-li" id="floating-toc_pallet.task.converge">pallet.task.converge</li><li class="floating-toc-li" id="floating-toc_pallet.task.describe-node">pallet.task.describe-node</li><li class="floating-toc-li" id="floating-toc_pallet.task.feedback">pallet.task.feedback</li><li class="floating-toc-li" id="floating-toc_pallet.task.help">pallet.task.help</li><li class="floating-toc-li" id="floating-toc_pallet.task.lift">pallet.task.lift</li><li class="floating-toc-li" id="floating-toc_pallet.task.new-project">pallet.task.new-project</li><li class="floating-toc-li" id="floating-toc_pallet.task.nodes">pallet.task.nodes</li><li class="floating-toc-li" id="floating-toc_pallet.task.providers">pallet.task.providers</li><li class="floating-toc-li" id="floating-toc_pallet.task.to-blob">pallet.task.to-blob</li><li class="floating-toc-li" id="floating-toc_pallet.task.version">pallet.task.version</li><li class="floating-toc-li" id="floating-toc_pallet.template.properties">pallet.template.properties</li><li class="floating-toc-li" id="floating-toc_pallet.template">pallet.template</li><li class="floating-toc-li" id="floating-toc_pallet.thread-expr">pallet.thread-expr</li><li class="floating-toc-li" id="floating-toc_pallet.utils">pallet.utils</li></ul></div></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>